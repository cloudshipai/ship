// MCP Server implementation for Ship CLI

package cli

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"strings"
	"unicode/utf8"

	shipMcp "github.com/cloudshipai/ship/internal/cli/mcp"
	"github.com/cloudshipai/ship/internal/telemetry"
	"github.com/cloudshipai/ship/pkg/ship"
	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
	"github.com/spf13/cobra"
)

// hardcodedMCPServers contains the built-in external MCP server configurations
var hardcodedMCPServers = map[string]ship.MCPServerConfig{
	"filesystem": {
		Name:      "filesystem",
		Command:   "npx",
		Args:      []string{"-y", "@modelcontextprotocol/server-filesystem", "/tmp"},
		Transport: "stdio",
		Env:       map[string]string{},
		Variables: []ship.Variable{
			{
				Name:        "FILESYSTEM_ROOT",
				Description: "Root directory for filesystem operations (overrides /tmp default)",
				Required:    false,
				Default:     "/tmp",
			},
		},
	},
	"memory": {
		Name:      "memory",
		Command:   "npx",
		Args:      []string{"-y", "@modelcontextprotocol/server-memory"},
		Transport: "stdio",
		Env:       map[string]string{},
		Variables: []ship.Variable{
			{
				Name:        "MEMORY_STORAGE_PATH",
				Description: "Path for persistent memory storage",
				Required:    false,
				Default:     "/tmp/mcp-memory",
			},
			{
				Name:        "MEMORY_MAX_SIZE",
				Description: "Maximum memory storage size (e.g., 100MB)",
				Required:    false,
				Default:     "50MB",
			},
		},
	},
	"brave-search": {
		Name:      "brave-search",
		Command:   "npx",
		Args:      []string{"-y", "@modelcontextprotocol/server-brave-search"},
		Transport: "stdio",
		Env:       map[string]string{},
		Variables: []ship.Variable{
			{
				Name:        "BRAVE_API_KEY",
				Description: "Brave Search API key for search functionality",
				Required:    true,
				Secret:      true,
			},
			{
				Name:        "BRAVE_SEARCH_COUNT",
				Description: "Number of search results to return (default: 10)",
				Required:    false,
				Default:     "10",
			},
		},
	},
	"aws-core": {
		Name:      "aws-core",
		Command:   "uvx",
		Args:      []string{"awslabs.core-mcp-server@latest"},
		Transport: "stdio",
		Env:       map[string]string{},
		Variables: []ship.Variable{
			{
				Name:        "AWS_PROFILE",
				Description: "AWS profile to use for authentication",
				Required:    false,
			},
			{
				Name:        "AWS_REGION",
				Description: "AWS region for operations",
				Required:    false,
				Default:     "us-east-1",
			},
			{
				Name:        "FASTMCP_LOG_LEVEL",
				Description: "Log level for the MCP server",
				Required:    false,
				Default:     "ERROR",
			},
		},
	},
	"aws-iam": {
		Name:      "aws-iam",
		Command:   "uvx",
		Args:      []string{"awslabs.iam-mcp-server@latest"},
		Transport: "stdio",
		Env:       map[string]string{},
		Variables: []ship.Variable{
			{
				Name:        "AWS_PROFILE",
				Description: "AWS profile to use for authentication",
				Required:    false,
			},
			{
				Name:        "AWS_REGION",
				Description: "AWS region for operations",
				Required:    false,
				Default:     "us-east-1",
			},
			{
				Name:        "FASTMCP_LOG_LEVEL",
				Description: "Log level for the MCP server",
				Required:    false,
				Default:     "ERROR",
			},
		},
	},
	"aws-pricing": {
		Name:      "aws-pricing",
		Command:   "uvx",
		Args:      []string{"awslabs.pricing-mcp-server@latest"},
		Transport: "stdio",
		Env:       map[string]string{},
		Variables: []ship.Variable{
			{
				Name:        "AWS_PROFILE",
				Description: "AWS profile to use for authentication",
				Required:    false,
			},
			{
				Name:        "AWS_REGION",
				Description: "AWS region for operations",
				Required:    false,
				Default:     "us-east-1",
			},
			{
				Name:        "FASTMCP_LOG_LEVEL",
				Description: "Log level for the MCP server",
				Required:    false,
				Default:     "ERROR",
			},
		},
	},
	"aws-eks": {
		Name:      "aws-eks",
		Command:   "uvx",
		Args:      []string{"awslabs.eks-mcp-server@latest"},
		Transport: "stdio",
		Env:       map[string]string{},
		Variables: []ship.Variable{
			{
				Name:        "AWS_PROFILE",
				Description: "AWS profile to use for authentication",
				Required:    false,
			},
			{
				Name:        "AWS_REGION",
				Description: "AWS region for operations",
				Required:    false,
				Default:     "us-east-1",
			},
			{
				Name:        "FASTMCP_LOG_LEVEL",
				Description: "Log level for the MCP server",
				Required:    false,
				Default:     "ERROR",
			},
		},
	},
	"aws-ec2": {
		Name:      "aws-ec2",
		Command:   "uvx",
		Args:      []string{"awslabs.ec2-mcp-server@latest"},
		Transport: "stdio",
		Env:       map[string]string{},
		Variables: []ship.Variable{
			{
				Name:        "AWS_PROFILE",
				Description: "AWS profile to use for authentication",
				Required:    false,
			},
			{
				Name:        "AWS_REGION",
				Description: "AWS region for operations",
				Required:    false,
				Default:     "us-east-1",
			},
			{
				Name:        "FASTMCP_LOG_LEVEL",
				Description: "Log level for the MCP server",
				Required:    false,
				Default:     "ERROR",
			},
		},
	},
	"aws-s3": {
		Name:      "aws-s3",
		Command:   "uvx",
		Args:      []string{"awslabs.s3-mcp-server@latest"},
		Transport: "stdio",
		Env:       map[string]string{},
		Variables: []ship.Variable{
			{
				Name:        "AWS_PROFILE",
				Description: "AWS profile to use for authentication",
				Required:    false,
			},
			{
				Name:        "AWS_REGION",
				Description: "AWS region for operations",
				Required:    false,
				Default:     "us-east-1",
			},
			{
				Name:        "FASTMCP_LOG_LEVEL",
				Description: "Log level for the MCP server",
				Required:    false,
				Default:     "ERROR",
			},
		},
	},
	"steampipe": {
		Name:      "steampipe",
		Command:   "npx",
		Args:      []string{"-y", "@turbot/steampipe-mcp"},
		Transport: "stdio",
		Env:       map[string]string{},
		Variables: []ship.Variable{
			{
				Name:        "STEAMPIPE_DATABASE_CONNECTIONS",
				Description: "Database connections configuration for Steampipe",
				Required:    false,
				Default:     "postgres://steampipe@localhost:9193/steampipe",
			},
		},
	},
}

var mcpCmd = &cobra.Command{
	Use:   "mcp [tool]",
	Short: "Start MCP server for a specific tool or all tools",
	Long: `Start an MCP server that exposes specific Ship CLI tools for AI assistants.

Available tools:
  # Terraform Tools
  lint         - TFLint for syntax and best practices
  checkov      - Checkov security scanning  
  trivy        - Trivy security scanning
  cost         - OpenInfraQuote cost analysis
  docs         - terraform-docs documentation
  diagram      - InfraMap diagram generation
  terraform-docs - Terraform documentation generation
  tflint       - Terraform linting
  terrascan    - Infrastructure as Code security scanning
  openinfraquote - Infrastructure cost estimation
  aws-pricing-builtin - Built-in AWS pricing information
  
  # Security Tools
  gitleaks     - Secret detection with Gitleaks
  grype        - Vulnerability scanning with Grype
  syft         - SBOM generation with Syft
  prowler      - Multi-cloud security assessment
  trufflehog   - Verified secret detection
  cosign       - Container signing and verification
  actionlint   - GitHub Actions workflow linting
  semgrep      - Static analysis security scanning
  hadolint     - Dockerfile security linting
  cfn-nag      - CloudFormation security scanning
  conftest     - OPA policy testing
  git-secrets  - Git secrets scanning
  kube-bench   - Kubernetes security benchmarks
  kube-hunter  - Kubernetes penetration testing
  zap          - Web application security testing
  falco        - Runtime security monitoring
  nikto        - Web server security scanning
  openscap     - Security compliance scanning
  ossf-scorecard - Open Source Security Foundation scorecard
  scout-suite  - Multi-cloud security auditing
  powerpipe    - Infrastructure benchmarking
  velero       - Kubernetes backup and disaster recovery
  goldilocks   - Kubernetes resource recommendations
  allstar      - GitHub security policy enforcement
  rekor        - Software supply chain transparency
  osv-scanner  - Open Source Vulnerability scanning
  license-detector - Software license detection
  registry     - Container registry operations
  cosign-golden - Enhanced Cosign for golden images
  history-scrub - Git history cleaning and secret removal
  iac-plan     - Infrastructure as Code planning
  slsa-verifier - SLSA provenance verification
  in-toto      - Supply chain attestation
  gatekeeper   - OPA Gatekeeper policy validation
  kubescape    - Kubernetes security scanning
  dockle       - Container image linting
  sops         - Secrets management with Mozilla SOPS
  dependency-track - OWASP Dependency-Track SBOM analysis
  guac         - GUAC supply chain analysis
  sigstore-policy-controller - Sigstore Policy Controller
  
  # Cloud & Infrastructure Tools
  cloudquery   - Cloud asset inventory
  custodian    - Cloud governance engine
  terraformer  - Infrastructure import and management
  infracost    - Infrastructure cost estimation
  inframap     - Infrastructure visualization
  infrascan    - Infrastructure security scanning
  aws-iam-rotation - AWS IAM credential rotation
  tfstate-reader - Terraform state analysis
  packer       - Machine image building
  fleet        - GitOps for Kubernetes
  kuttl        - Kubernetes testing framework
  litmus       - Chaos engineering for Kubernetes
  cert-manager - Certificate management
  step-ca      - Certificate authority operations
  check-ssl-cert - SSL certificate validation
  k8s-network-policy - Kubernetes network policy management
  kyverno      - Kubernetes policy management
  kyverno-multitenant - Multi-tenant Kyverno policies
  github-admin - GitHub administration tools
  github-packages - GitHub Packages security
  trivy-golden - Enhanced Trivy for golden images
  
  # AWS IAM Tools
  cloudsplaining - AWS IAM security assessment
  parliament     - AWS IAM policy linting
  pmapper        - AWS IAM privilege mapping
  policy-sentry  - AWS IAM policy generation
  
  # Collections
  terraform  - All Terraform tools
  security   - All security tools
  aws-iam    - All AWS IAM tools
  cloud      - All cloud infrastructure tools
  kubernetes - All Kubernetes tools
  all        - All tools (default if no tool specified)

External MCP Servers:
  filesystem     - Filesystem operations MCP server
  memory         - Memory/knowledge storage MCP server
  brave-search   - Brave search MCP server
  steampipe      - Cloud infrastructure queries MCP server
  
  # AWS Labs Official MCP Servers
  aws-core       - AWS core operations and general services
  aws-iam        - AWS IAM operations and identity management  
  aws-pricing    - AWS pricing and cost estimation
  aws-eks        - AWS EKS and Kubernetes operations
  aws-ec2        - AWS EC2 compute operations
  aws-s3         - AWS S3 storage operations

Examples:
  # Our Security & Infrastructure Tools
  ship mcp lint        # MCP server for just TFLint
  ship mcp checkov     # MCP server for just Checkov
  ship mcp all         # MCP server for all tools
  
  # External MCP Servers
  ship mcp filesystem     # Proxy filesystem operations MCP server
  ship mcp memory         # Proxy memory/knowledge storage MCP server
  ship mcp brave-search --var BRAVE_API_KEY=your_api_key   # Proxy Brave search with API key
  ship mcp steampipe                                       # Proxy Steampipe for cloud infrastructure queries
  
  # AWS Labs Official MCP Servers (requires 'uv' and AWS credentials)
  ship mcp aws-core --var AWS_PROFILE=default             # AWS core operations
  ship mcp aws-iam --var AWS_REGION=us-west-2             # AWS IAM management
  ship mcp aws-pricing                                     # AWS pricing queries
  ship mcp aws-eks --var AWS_PROFILE=production           # EKS operations
  ship mcp aws-ec2 --var AWS_REGION=eu-west-1             # EC2 operations
  ship mcp aws-s3                                          # S3 operations
  
  ship mcp cost --var AWS_REGION=us-east-1 --var DEBUG=true  # Pass multiple environment variables`,
	Args: cobra.MaximumNArgs(1),
	RunE: runMCPServer,
}

func init() {
	rootCmd.AddCommand(mcpCmd)

	mcpCmd.Flags().Int("port", 0, "Port to listen on (0 for stdio)")
	mcpCmd.Flags().String("host", "localhost", "Host to bind to")
	mcpCmd.Flags().Bool("stdio", true, "Use stdio transport (default)")
	mcpCmd.Flags().StringToString("var", nil, "Environment variables for MCP servers and containers (e.g., --var API_KEY=value --var DEBUG=true)")
}

func runMCPServer(cmd *cobra.Command, args []string) error {
	port, _ := cmd.Flags().GetInt("port")
	host, _ := cmd.Flags().GetString("host")
	useStdio, _ := cmd.Flags().GetBool("stdio")
	envVars, _ := cmd.Flags().GetStringToString("var")

	// Determine which tool to serve
	toolName := "all"
	if len(args) > 0 {
		toolName = args[0]
	}

	// Track MCP command usage
	telemetry.TrackMCPCommand(toolName)

	// Create MCP server
	serverName := fmt.Sprintf("ship-%s", toolName)
	s := server.NewMCPServer(serverName, "1.0.0")

	// Set environment variables for containerized tools
	if len(envVars) > 0 {
		setContainerEnvironmentVars(envVars)
	}

	// Add specific tools based on argument using the modular registry
	switch toolName {
	case "all":
		// Register all tools from all categories
		shipMcp.RegisterAllTools(s, executeShipCommand)
	case "terraform", "security", "aws", "kubernetes", "cloud", "supply-chain":
		// Register tools by category
		shipMcp.RegisterToolsByCategory(toolName, s, executeShipCommand)
	default:
		// Check if this is a specific tool name
		shipMcp.RegisterToolByName(toolName, s, executeShipCommand)
		
		// If no tools were registered, check if it's an external MCP server  
		// Note: we can't check s.Tools() as it's not exposed, so we'll assume tool was registered
		// If the tool doesn't exist, the registry function will handle it gracefully
		// External MCP servers are handled by checking the hardcoded list
		if isExternalMCPServer(toolName) {
			return runMCPProxy(cmd, toolName)
		}
	}

	// Add resources for documentation and help
	addResources(s)

	// Add prompts only for 'all' mode
	if toolName == "all" {
		addPrompts(s)
	}

	// Start server
	if useStdio || port == 0 {
		fmt.Fprintf(os.Stderr, "Starting %s MCP server on stdio...\n", serverName)
		return server.ServeStdio(s)
	} else {
		fmt.Fprintf(os.Stderr, "Starting %s MCP server on %s:%d...\n", serverName, host, port)
		return fmt.Errorf("HTTP server not implemented in this version, use --stdio")
	}
}

// Individual tool functions
func addLintTool(s *server.MCPServer) {
	lintTool := mcp.NewTool("lint",
		mcp.WithDescription("Run TFLint on Terraform code to check for syntax errors and best practices"),
		mcp.WithString("directory",
			mcp.Description("Directory containing Terraform files (default: current directory)"),
		),
		mcp.WithString("format",
			mcp.Description("Output format: default, json, compact"),
			mcp.Enum("default", "json", "compact"),
		),
		mcp.WithString("output",
			mcp.Description("Output file to save lint results"),
		),
	)

	s.AddTool(lintTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"tf", "lint"}

		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		if format := request.GetString("format", ""); format != "" {
			args = append(args, "--format", format)
		}
		if output := request.GetString("output", ""); output != "" {
			args = append(args, "--output", output)
		}

		return executeShipCommand(args)
	})
}

func addCheckovTools(s *server.MCPServer) {
	// Checkov scan directory tool
	scanDirTool := mcp.NewTool("checkov_scan_directory",
		mcp.WithDescription("Scan a directory for security issues using Checkov"),
		mcp.WithString("directory",
			mcp.Description("Directory to scan (default: current directory)"),
		),
	)
	s.AddTool(scanDirTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"tf", "checkov"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		return executeShipCommand(args)
	})

	// Checkov scan file tool
	scanFileTool := mcp.NewTool("checkov_scan_file",
		mcp.WithDescription("Scan a specific file for security issues using Checkov"),
		mcp.WithString("file_path",
			mcp.Description("Path to the file to scan"),
		),
	)
	s.AddTool(scanFileTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"tf", "checkov"}
		if filePath := request.GetString("file_path", ""); filePath != "" {
			args = append(args, "--file", filePath)
		}
		return executeShipCommand(args)
	})

	// Checkov scan with policy tool
	scanWithPolicyTool := mcp.NewTool("checkov_scan_with_policy",
		mcp.WithDescription("Scan with custom policy using Checkov"),
		mcp.WithString("directory",
			mcp.Description("Directory to scan (default: current directory)"),
		),
		mcp.WithString("policy_path",
			mcp.Description("Path to custom policy file"),
		),
	)
	s.AddTool(scanWithPolicyTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"tf", "checkov"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		if policyPath := request.GetString("policy_path", ""); policyPath != "" {
			args = append(args, "--policy", policyPath)
		}
		return executeShipCommand(args)
	})

	// Checkov scan multi-framework tool
	scanMultiFrameworkTool := mcp.NewTool("checkov_scan_multi_framework",
		mcp.WithDescription("Scan with multiple frameworks using Checkov"),
		mcp.WithString("directory",
			mcp.Description("Directory to scan (default: current directory)"),
		),
		mcp.WithString("frameworks",
			mcp.Description("Comma-separated list of frameworks"),
			mcp.Enum("terraform", "cloudformation", "kubernetes", "dockerfile", "arm"),
		),
	)
	s.AddTool(scanMultiFrameworkTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"tf", "checkov"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		if frameworks := request.GetString("frameworks", ""); frameworks != "" {
			args = append(args, "--framework", frameworks)
		}
		return executeShipCommand(args)
	})

	// Checkov scan with severity tool
	scanWithSeverityTool := mcp.NewTool("checkov_scan_with_severity",
		mcp.WithDescription("Scan with severity threshold using Checkov"),
		mcp.WithString("directory",
			mcp.Description("Directory to scan (default: current directory)"),
		),
		mcp.WithString("severities",
			mcp.Description("Comma-separated list of severities"),
			mcp.Enum("LOW", "MEDIUM", "HIGH", "CRITICAL"),
		),
	)
	s.AddTool(scanWithSeverityTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"tf", "checkov"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		if severities := request.GetString("severities", ""); severities != "" {
			args = append(args, "--severity", severities)
		}
		return executeShipCommand(args)
	})

	// Checkov scan with skips tool
	scanWithSkipsTool := mcp.NewTool("checkov_scan_with_skips",
		mcp.WithDescription("Scan with skipped checks using Checkov"),
		mcp.WithString("directory",
			mcp.Description("Directory to scan (default: current directory)"),
		),
		mcp.WithString("skip_checks",
			mcp.Description("Comma-separated list of check IDs to skip"),
		),
	)
	s.AddTool(scanWithSkipsTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"tf", "checkov"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		if skipChecks := request.GetString("skip_checks", ""); skipChecks != "" {
			args = append(args, "--skip-check", skipChecks)
		}
		return executeShipCommand(args)
	})

	// Checkov get version tool
	getVersionTool := mcp.NewTool("checkov_get_version",
		mcp.WithDescription("Get Checkov version information"),
	)
	s.AddTool(getVersionTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"tf", "checkov", "--version"}
		return executeShipCommand(args)
	})
}

func addTrivyTools(s *server.MCPServer) {
	// Trivy scan image tool
	scanImageTool := mcp.NewTool("trivy_scan_image",
		mcp.WithDescription("Scan container image for vulnerabilities using Trivy"),
		mcp.WithString("image_name",
			mcp.Description("Container image name to scan"),
		),
	)
	s.AddTool(scanImageTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "trivy", "image"}
		if imageName := request.GetString("image_name", ""); imageName != "" {
			args = append(args, imageName)
		}
		return executeShipCommand(args)
	})

	// Trivy scan filesystem tool
	scanFilesystemTool := mcp.NewTool("trivy_scan_filesystem",
		mcp.WithDescription("Scan filesystem for vulnerabilities using Trivy"),
		mcp.WithString("directory",
			mcp.Description("Directory to scan (default: current directory)"),
		),
	)
	s.AddTool(scanFilesystemTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "trivy", "fs"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		return executeShipCommand(args)
	})

	// Trivy scan repository tool
	scanRepositoryTool := mcp.NewTool("trivy_scan_repository",
		mcp.WithDescription("Scan git repository for vulnerabilities using Trivy"),
		mcp.WithString("repo_url",
			mcp.Description("Git repository URL to scan"),
		),
	)
	s.AddTool(scanRepositoryTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "trivy", "repo"}
		if repoURL := request.GetString("repo_url", ""); repoURL != "" {
			args = append(args, repoURL)
		}
		return executeShipCommand(args)
	})

	// Trivy scan config tool
	scanConfigTool := mcp.NewTool("trivy_scan_config",
		mcp.WithDescription("Scan configuration files for security issues using Trivy"),
		mcp.WithString("directory",
			mcp.Description("Directory containing configuration files (default: current directory)"),
		),
	)
	s.AddTool(scanConfigTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "trivy", "config"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		return executeShipCommand(args)
	})

	// Trivy get version tool
	getVersionTool := mcp.NewTool("trivy_get_version",
		mcp.WithDescription("Get Trivy version information"),
	)
	s.AddTool(getVersionTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "trivy", "--version"}
		return executeShipCommand(args)
	})
}

func addCostTool(s *server.MCPServer) {
	costTool := mcp.NewTool("cost",
		mcp.WithDescription("Analyze infrastructure costs using OpenInfraQuote"),
		mcp.WithString("directory",
			mcp.Description("Directory containing Terraform files (default: current directory)"),
		),
		mcp.WithString("region",
			mcp.Description("AWS region for pricing (e.g., us-east-1, us-west-2)"),
		),
		mcp.WithString("format",
			mcp.Description("Output format: json, table"),
			mcp.Enum("json", "table"),
		),
		mcp.WithString("output",
			mcp.Description("Output file to save cost analysis"),
		),
	)

	s.AddTool(costTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"tf", "cost"}

		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		if region := request.GetString("region", ""); region != "" {
			args = append(args, "--region", region)
		}
		if format := request.GetString("format", ""); format != "" {
			args = append(args, "--format", format)
		}
		if output := request.GetString("output", ""); output != "" {
			args = append(args, "--output", output)
		}

		return executeShipCommand(args)
	})
}

func addDocsTool(s *server.MCPServer) {
	docsTool := mcp.NewTool("docs",
		mcp.WithDescription("Generate documentation for Terraform modules using terraform-docs"),
		mcp.WithString("directory",
			mcp.Description("Directory containing Terraform files (default: current directory)"),
		),
		mcp.WithString("filename",
			mcp.Description("Filename to save documentation as (default README.md)"),
		),
		mcp.WithString("output",
			mcp.Description("Output file to save documentation"),
		),
	)

	s.AddTool(docsTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"tf", "docs"}

		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		if filename := request.GetString("filename", ""); filename != "" {
			args = append(args, "--filename", filename)
		}
		if output := request.GetString("output", ""); output != "" {
			args = append(args, "--output", output)
		}

		return executeShipCommand(args)
	})
}

func addDiagramTool(s *server.MCPServer) {
	diagramTool := mcp.NewTool("diagram",
		mcp.WithDescription("Generate infrastructure diagrams from Terraform state"),
		mcp.WithString("input",
			mcp.Description("Input directory or file containing Terraform files (default: current directory)"),
		),
		mcp.WithString("format",
			mcp.Description("Output format: png, svg, pdf, dot"),
			mcp.Enum("png", "svg", "pdf", "dot"),
		),
		mcp.WithString("output",
			mcp.Description("Output file to save diagram"),
		),
		mcp.WithBoolean("hcl",
			mcp.Description("Generate from HCL files instead of state file"),
		),
		mcp.WithString("provider",
			mcp.Description("Filter by specific provider (aws, google, azurerm)"),
			mcp.Enum("aws", "google", "azurerm"),
		),
	)

	s.AddTool(diagramTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"tf", "diagram"}

		if input := request.GetString("input", ""); input != "" {
			args = append(args, input)
		}
		if format := request.GetString("format", ""); format != "" {
			args = append(args, "--format", format)
		}
		if output := request.GetString("output", ""); output != "" {
			args = append(args, "--output", output)
		}
		if hcl := request.GetBool("hcl", false); hcl {
			args = append(args, "--hcl")
		}
		if provider := request.GetString("provider", ""); provider != "" {
			args = append(args, "--provider", provider)
		}

		return executeShipCommand(args)
	})
}

func addTerraformTools(s *server.MCPServer) {
	// Terraform Lint Tool
	lintTool := mcp.NewTool("lint",
		mcp.WithDescription("Run TFLint on Terraform code to check for syntax errors and best practices"),
		mcp.WithString("directory",
			mcp.Description("Directory containing Terraform files (default: current directory)"),
		),
		mcp.WithString("format",
			mcp.Description("Output format: default, json, compact"),
			mcp.Enum("default", "json", "compact"),
		),
		mcp.WithString("output",
			mcp.Description("Output file to save lint results"),
		),
	)

	s.AddTool(lintTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"tf", "lint"}

		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		if format := request.GetString("format", ""); format != "" {
			args = append(args, "--format", format)
		}
		if output := request.GetString("output", ""); output != "" {
			args = append(args, "--output", output)
		}

		return executeShipCommand(args)
	})

	// Terraform Security Scan Tool (Checkov)
	checkovTool := mcp.NewTool("checkov",
		mcp.WithDescription("Run Checkov security scan on Terraform code for policy compliance"),
		mcp.WithString("directory",
			mcp.Description("Directory containing Terraform files (default: current directory)"),
		),
		mcp.WithString("format",
			mcp.Description("Output format: cli, json, junit, sarif"),
			mcp.Enum("cli", "json", "junit", "sarif"),
		),
		mcp.WithString("output",
			mcp.Description("Output file to save scan results"),
		),
	)

	s.AddTool(checkovTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"tf", "checkov"}

		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		if format := request.GetString("format", ""); format != "" {
			args = append(args, "--format", format)
		}
		if output := request.GetString("output", ""); output != "" {
			args = append(args, "--output", output)
		}

		return executeShipCommand(args)
	})

	// Terraform Security Scan Tool (Alternative)
	securityTool := mcp.NewTool("trivy",
		mcp.WithDescription("Run alternative security scan on Terraform code using Trivy"),
		mcp.WithString("directory",
			mcp.Description("Directory containing Terraform files (default: current directory)"),
		),
	)

	s.AddTool(securityTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"tf", "trivy"}

		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		// Push functionality disabled during staging
		// if push := request.GetBool("push", false); push {
		//	args = append(args, "--push")
		// }

		return executeShipCommand(args)
	})

	// Terraform Cost Analysis Tool
	costAnalysisTool := mcp.NewTool("cost",
		mcp.WithDescription("Analyze infrastructure costs using OpenInfraQuote"),
		mcp.WithString("directory",
			mcp.Description("Directory containing Terraform files (default: current directory)"),
		),
		mcp.WithString("region",
			mcp.Description("AWS region for pricing (e.g., us-east-1, us-west-2)"),
		),
		mcp.WithString("format",
			mcp.Description("Output format: json, table"),
			mcp.Enum("json", "table"),
		),
		mcp.WithString("output",
			mcp.Description("Output file to save cost analysis"),
		),
	)

	s.AddTool(costAnalysisTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"tf", "cost"}

		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		if region := request.GetString("region", ""); region != "" {
			args = append(args, "--region", region)
		}
		if format := request.GetString("format", ""); format != "" {
			args = append(args, "--format", format)
		}
		if output := request.GetString("output", ""); output != "" {
			args = append(args, "--output", output)
		}

		return executeShipCommand(args)
	})

	// Terraform Documentation Tool
	docsTool := mcp.NewTool("docs",
		mcp.WithDescription("Generate documentation for Terraform modules using terraform-docs"),
		mcp.WithString("directory",
			mcp.Description("Directory containing Terraform files (default: current directory)"),
		),
		mcp.WithString("filename",
			mcp.Description("Filename to save documentation as (default README.md)"),
		),
		mcp.WithString("output",
			mcp.Description("Output file to save documentation"),
		),
	)

	s.AddTool(docsTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"tf", "docs"}

		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		if filename := request.GetString("filename", ""); filename != "" {
			args = append(args, "--filename", filename)
		}
		if output := request.GetString("output", ""); output != "" {
			args = append(args, "--output", output)
		}

		return executeShipCommand(args)
	})

	// Terraform Diagram Generation Tool
	diagramTool := mcp.NewTool("diagram",
		mcp.WithDescription("Generate infrastructure diagrams from Terraform state"),
		mcp.WithString("input",
			mcp.Description("Input directory or file containing Terraform files (default: current directory)"),
		),
		mcp.WithString("format",
			mcp.Description("Output format: png, svg, pdf, dot"),
			mcp.Enum("png", "svg", "pdf", "dot"),
		),
		mcp.WithString("output",
			mcp.Description("Output file to save diagram"),
		),
		mcp.WithBoolean("hcl",
			mcp.Description("Generate from HCL files instead of state file"),
		),
		mcp.WithString("provider",
			mcp.Description("Filter by specific provider (aws, google, azurerm)"),
			mcp.Enum("aws", "google", "azurerm"),
		),
	)

	s.AddTool(diagramTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"tf", "diagram"}

		if input := request.GetString("input", ""); input != "" {
			args = append(args, input)
		}
		if format := request.GetString("format", ""); format != "" {
			args = append(args, "--format", format)
		}
		if output := request.GetString("output", ""); output != "" {
			args = append(args, "--output", output)
		}
		if hcl := request.GetBool("hcl", false); hcl {
			args = append(args, "--hcl")
		}
		if provider := request.GetString("provider", ""); provider != "" {
			args = append(args, "--provider", provider)
		}

		return executeShipCommand(args)
	})
}

// Investigation tools removed to focus on Terraform analysis workflows

func addResources(s *server.MCPServer) {
	// Help resource
	helpResource := mcp.NewResource("ship://help",
		"Ship CLI Help",
		mcp.WithResourceDescription("Complete help and usage information for Ship CLI"),
		mcp.WithMIMEType("text/markdown"),
	)

	s.AddResource(helpResource, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
		result, err := executeShipCommand([]string{"--help"})
		if err != nil {
			return nil, err
		}

		// Extract text from result - the result should be a simple text response
		var helpText string
		if result != nil && len(result.Content) > 0 {
			if textContent, ok := result.Content[0].(mcp.TextContent); ok {
				helpText = textContent.Text
			}
		}

		return []mcp.ResourceContents{
			mcp.TextResourceContents{
				URI:      "ship://help",
				MIMEType: "text/markdown",
				Text:     helpText,
			},
		}, nil
	})

	// Available tools resource
	toolsResource := mcp.NewResource("ship://tools",
		"Available Ship CLI Tools",
		mcp.WithResourceDescription("List of all available Ship CLI tools and their capabilities"),
		mcp.WithMIMEType("text/markdown"),
	)

	s.AddResource(toolsResource, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
		content := `# Ship CLI Tools

## Terraform Tools
- **lint**: Run TFLint for syntax and best practices
- **checkov**: Security scanning with Checkov
- **trivy**: Alternative security scanning with Trivy
- **cost**: Cost analysis with OpenInfraQuote
- **docs**: Generate documentation with terraform-docs
- **diagram**: Generate infrastructure diagrams with InfraMap


## Examples
- ` + "`ship tf lint`" + ` - Lint current directory
- ` + "`ship tf diagram . --hcl --format png`" + ` - Generate infrastructure diagram
`

		return []mcp.ResourceContents{
			mcp.TextResourceContents{
				URI:      "ship://tools",
				MIMEType: "text/markdown",
				Text:     content,
			},
		}, nil
	})
}

func addPrompts(s *server.MCPServer) {
	// Security audit prompt
	securityPrompt := mcp.NewPrompt("security_audit",
		mcp.WithPromptDescription("Comprehensive security audit of cloud infrastructure"),
		mcp.WithArgument("provider",
			mcp.ArgumentDescription("Cloud provider to audit (aws, azure, gcp)"),
		),
	)

	s.AddPrompt(securityPrompt, func(ctx context.Context, request mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
		return &mcp.GetPromptResult{
			Description: "Comprehensive security audit workflow",
			Messages: []mcp.PromptMessage{
				{
					Role: "user",
					Content: mcp.TextContent{
						Type: "text",
						Text: `Please perform a comprehensive security audit of my Terraform infrastructure. Follow these steps:

1. Run terraform_checkov_scan to identify security issues in infrastructure-as-code
2. Run terraform_security_scan for additional security analysis  
3. Use terraform_lint to check for configuration best practices

4. Summarize all findings with:
   - Critical security issues requiring immediate attention
   - Recommendations for improvement
   - Best practices to implement

Please be thorough and provide actionable recommendations.`,
					},
				},
			},
		}, nil
	})

	// Cost optimization prompt
	costPrompt := mcp.NewPrompt("cost_optimization",
		mcp.WithPromptDescription("Identify cost optimization opportunities"),
		mcp.WithArgument("provider",
			mcp.ArgumentDescription("Cloud provider to analyze (aws, azure, gcp)"),
		),
	)

	s.AddPrompt(costPrompt, func(ctx context.Context, request mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
		return &mcp.GetPromptResult{
			Description: "Cost optimization analysis workflow",
			Messages: []mcp.PromptMessage{
				{
					Role: "user",
					Content: mcp.TextContent{
						Type: "text",
						Text: `Help me optimize costs for my Terraform infrastructure:

1. Use terraform_cost_analysis to analyze current cost projections
2. Review Terraform configurations for cost optimization opportunities
3. Use terraform_lint to identify inefficient resource configurations

4. Provide a prioritized list of cost-saving recommendations:
   - Quick wins (resource rightsizing, unused resources)
   - Medium-term optimizations (reserved instances, storage classes)
   - Long-term architectural improvements

Include estimated cost savings where possible.`,
					},
				},
			},
		}, nil
	})
}

// Maximum tokens allowed in MCP response (conservative estimate)
const maxMCPTokens = 20000

// Rough estimation: 1 token â‰ˆ 4 characters for typical text
const charsPerToken = 4

// Security Tools
func addSecurityTools(s *server.MCPServer) {
	// Existing security tools with MCP integration
	addGitleaksTools(s)
	addGrypleTools(s)
	addSyftTools(s)
	addProwlerTools(s)
	addTruffleHogTools(s)
	addCosignTools(s)

	// New high-priority security tools with full MCP integration
	addSLSAVerifierTool(s)
	addInTotoTool(s)
	addGatekeeperTool(s)
	addKubescapeTools(s)
	addDockleTool(s)
	addSOPSTool(s)

	// Additional security tools with MCP integration
	addActionlintTools(s)
	addSemgrepTools(s)
	addHadolintTools(s)
	addCfnNagTool(s)
	addConftestTools(s)
	addGitSecretsTools(s)
	addKubeBenchTool(s)
	addKubeHunterTool(s)
	addZapTools(s)
	addFalcoTools(s)
	addNiktoTools(s)
	addOpenSCAPTool(s)
	addOSSFScorecardTool(s)
	addScoutSuiteTool(s)
	addPowerpipeTool(s)
	addVeleroTool(s)
	addGoldilocksTool(s)
	addAllstarTool(s)
	addRekorTool(s)
	addOSVScannerTool(s)
	addLicenseDetectorTool(s)
	addRegistryTool(s)
	addCosignGoldenTool(s)
	addHistoryScrubTool(s)
	addTrivyGoldenTool(s)
	addIacPlanTool(s)

	// Supply chain security tools
	addDependencyTrackTool(s)
	addGuacTool(s)
	addSigstorePolicyControllerTool(s)
}

func addGitleaksTools(s *server.MCPServer) {
	// Gitleaks scan directory tool
	scanDirTool := mcp.NewTool("gitleaks_scan_directory",
		mcp.WithDescription("Scan a directory for secrets using Gitleaks"),
		mcp.WithString("directory",
			mcp.Description("Directory to scan (default: current directory)"),
		),
	)
	s.AddTool(scanDirTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "gitleaks"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		return executeShipCommand(args)
	})

	// Gitleaks scan file tool
	scanFileTool := mcp.NewTool("gitleaks_scan_file",
		mcp.WithDescription("Scan a specific file for secrets using Gitleaks"),
		mcp.WithString("file_path",
			mcp.Description("Path to the file to scan"),
		),
	)
	s.AddTool(scanFileTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "gitleaks"}
		if filePath := request.GetString("file_path", ""); filePath != "" {
			args = append(args, filePath)
		}
		return executeShipCommand(args)
	})

	// Gitleaks scan git repository tool
	scanGitTool := mcp.NewTool("gitleaks_scan_git_repo",
		mcp.WithDescription("Scan a git repository for secrets using Gitleaks"),
		mcp.WithString("repository",
			mcp.Description("Path to git repository (default: current directory)"),
		),
	)
	s.AddTool(scanGitTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "gitleaks"}
		if repo := request.GetString("repository", ""); repo != "" {
			args = append(args, repo)
		}
		args = append(args, "--git")
		return executeShipCommand(args)
	})

	// Gitleaks scan with config tool
	scanConfigTool := mcp.NewTool("gitleaks_scan_with_config",
		mcp.WithDescription("Scan using custom Gitleaks configuration"),
		mcp.WithString("directory",
			mcp.Description("Directory to scan (default: current directory)"),
		),
		mcp.WithString("config",
			mcp.Description("Path to Gitleaks configuration file"),
		),
	)
	s.AddTool(scanConfigTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "gitleaks"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		if config := request.GetString("config", ""); config != "" {
			args = append(args, "--config", config)
		}
		return executeShipCommand(args)
	})
}

func addGrypleTools(s *server.MCPServer) {
	// Grype scan directory tool
	scanDirTool := mcp.NewTool("grype_scan_directory",
		mcp.WithDescription("Scan a directory for vulnerabilities using Grype"),
		mcp.WithString("directory",
			mcp.Description("Directory to scan (default: current directory)"),
		),
	)
	s.AddTool(scanDirTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "grype"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		return executeShipCommand(args)
	})

	// Grype scan image tool
	scanImageTool := mcp.NewTool("grype_scan_image",
		mcp.WithDescription("Scan a container image for vulnerabilities using Grype"),
		mcp.WithString("image_name",
			mcp.Description("Container image name to scan"),
		),
	)
	s.AddTool(scanImageTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "grype"}
		if image := request.GetString("image_name", ""); image != "" {
			args = append(args, image)
		}
		return executeShipCommand(args)
	})

	// Grype scan SBOM tool
	scanSBOMTool := mcp.NewTool("grype_scan_sbom",
		mcp.WithDescription("Scan an SBOM file for vulnerabilities using Grype"),
		mcp.WithString("sbom_path",
			mcp.Description("Path to SBOM file to scan"),
		),
	)
	s.AddTool(scanSBOMTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "grype"}
		if sbom := request.GetString("sbom_path", ""); sbom != "" {
			args = append(args, sbom)
		}
		return executeShipCommand(args)
	})

	// Grype scan with severity threshold tool
	scanSeverityTool := mcp.NewTool("grype_scan_with_severity",
		mcp.WithDescription("Scan with specific severity threshold using Grype"),
		mcp.WithString("target",
			mcp.Description("Target to scan (directory or image)"),
		),
		mcp.WithString("severity",
			mcp.Description("Minimum severity level"),
			mcp.Enum("negligible", "low", "medium", "high", "critical"),
		),
	)
	s.AddTool(scanSeverityTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "grype"}
		if target := request.GetString("target", ""); target != "" {
			args = append(args, target)
		}
		if severity := request.GetString("severity", ""); severity != "" {
			args = append(args, "--severity", severity)
		}
		return executeShipCommand(args)
	})
}

func addSyftTools(s *server.MCPServer) {
	// Syft generate SBOM from directory tool
	generateDirTool := mcp.NewTool("syft_generate_sbom_directory",
		mcp.WithDescription("Generate SBOM from a directory using Syft"),
		mcp.WithString("directory",
			mcp.Description("Directory to scan (default: current directory)"),
		),
		mcp.WithString("format",
			mcp.Description("Output format"),
			mcp.Enum("json", "spdx-json", "cyclonedx-json", "table"),
		),
	)
	s.AddTool(generateDirTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "syft"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		if format := request.GetString("format", ""); format != "" {
			args = append(args, "--format", format)
		}
		return executeShipCommand(args)
	})

	// Syft generate SBOM from image tool
	generateImageTool := mcp.NewTool("syft_generate_sbom_image",
		mcp.WithDescription("Generate SBOM from a container image using Syft"),
		mcp.WithString("image_name",
			mcp.Description("Container image name to scan"),
		),
		mcp.WithString("format",
			mcp.Description("Output format"),
			mcp.Enum("json", "spdx-json", "cyclonedx-json", "table"),
		),
	)
	s.AddTool(generateImageTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "syft"}
		if image := request.GetString("image_name", ""); image != "" {
			args = append(args, image)
		}
		if format := request.GetString("format", ""); format != "" {
			args = append(args, "--format", format)
		}
		return executeShipCommand(args)
	})

	// Syft generate SBOM for specific package type tool
	generatePackageTool := mcp.NewTool("syft_generate_sbom_package",
		mcp.WithDescription("Generate SBOM for specific package type using Syft"),
		mcp.WithString("directory",
			mcp.Description("Directory to scan (default: current directory)"),
		),
		mcp.WithString("package_type",
			mcp.Description("Package type to scan"),
			mcp.Enum("npm", "yarn", "pip", "python", "go", "maven", "gradle"),
		),
		mcp.WithString("format",
			mcp.Description("Output format"),
			mcp.Enum("json", "spdx-json", "cyclonedx-json", "table"),
		),
	)
	s.AddTool(generatePackageTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "syft"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		if packageType := request.GetString("package_type", ""); packageType != "" {
			args = append(args, "--package-type", packageType)
		}
		if format := request.GetString("format", ""); format != "" {
			args = append(args, "--format", format)
		}
		return executeShipCommand(args)
	})

	// Syft generate SBOM with attestations tool
	generateAttestationsTool := mcp.NewTool("syft_generate_sbom_attestations",
		mcp.WithDescription("Generate SBOM with attestations using Syft"),
		mcp.WithString("target",
			mcp.Description("Target to scan (directory or image)"),
		),
		mcp.WithString("format",
			mcp.Description("Output format"),
			mcp.Enum("json", "spdx-json", "cyclonedx-json"),
		),
	)
	s.AddTool(generateAttestationsTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "syft"}
		if target := request.GetString("target", ""); target != "" {
			args = append(args, target)
		}
		if format := request.GetString("format", ""); format != "" {
			args = append(args, "--format", format)
		}
		args = append(args, "--attestations")
		return executeShipCommand(args)
	})
}

func addProwlerTools(s *server.MCPServer) {
	// Prowler scan AWS tool
	scanAWSTool := mcp.NewTool("prowler_scan_aws",
		mcp.WithDescription("Scan AWS infrastructure for security issues using Prowler"),
		mcp.WithString("region",
			mcp.Description("AWS region for scanning (default: us-east-1)"),
		),
	)
	s.AddTool(scanAWSTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "prowler", "aws"}
		if region := request.GetString("region", ""); region != "" {
			args = append(args, "--region", region)
		}
		return executeShipCommand(args)
	})

	// Prowler scan Azure tool
	scanAzureTool := mcp.NewTool("prowler_scan_azure",
		mcp.WithDescription("Scan Azure infrastructure for security issues using Prowler"),
	)
	s.AddTool(scanAzureTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "prowler", "azure"}
		return executeShipCommand(args)
	})

	// Prowler scan GCP tool
	scanGCPTool := mcp.NewTool("prowler_scan_gcp",
		mcp.WithDescription("Scan Google Cloud Platform for security issues using Prowler"),
		mcp.WithString("project_id",
			mcp.Description("GCP project ID to scan"),
		),
	)
	s.AddTool(scanGCPTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "prowler", "gcp"}
		if projectId := request.GetString("project_id", ""); projectId != "" {
			args = append(args, "--project-id", projectId)
		}
		return executeShipCommand(args)
	})

	// Prowler scan Kubernetes tool
	scanKubernetesTool := mcp.NewTool("prowler_scan_kubernetes",
		mcp.WithDescription("Scan Kubernetes cluster for security issues using Prowler"),
		mcp.WithString("kubeconfig_path",
			mcp.Description("Path to kubeconfig file"),
		),
	)
	s.AddTool(scanKubernetesTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "prowler", "kubernetes"}
		if kubeconfigPath := request.GetString("kubeconfig_path", ""); kubeconfigPath != "" {
			args = append(args, "--kubeconfig", kubeconfigPath)
		}
		return executeShipCommand(args)
	})

	// Prowler scan with compliance tool
	scanComplianceTool := mcp.NewTool("prowler_scan_with_compliance",
		mcp.WithDescription("Scan with specific compliance frameworks using Prowler"),
		mcp.WithString("provider",
			mcp.Description("Cloud provider to scan"),
			mcp.Enum("aws", "azure", "gcp"),
		),
		mcp.WithString("compliance",
			mcp.Description("Compliance framework"),
			mcp.Enum("cis", "pci", "gdpr", "hipaa"),
		),
		mcp.WithString("region",
			mcp.Description("AWS region for scanning"),
		),
	)
	s.AddTool(scanComplianceTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "prowler"}
		if provider := request.GetString("provider", ""); provider != "" {
			args = append(args, provider)
		}
		if compliance := request.GetString("compliance", ""); compliance != "" {
			args = append(args, "--compliance", compliance)
		}
		if region := request.GetString("region", ""); region != "" {
			args = append(args, "--region", region)
		}
		return executeShipCommand(args)
	})

	// Prowler scan specific services tool
	scanServicesTool := mcp.NewTool("prowler_scan_specific_services",
		mcp.WithDescription("Scan specific cloud services using Prowler"),
		mcp.WithString("provider",
			mcp.Description("Cloud provider to scan"),
			mcp.Enum("aws", "azure", "gcp"),
		),
		mcp.WithString("services",
			mcp.Description("Specific services to scan (comma-separated)"),
		),
		mcp.WithString("region",
			mcp.Description("AWS region for scanning"),
		),
	)
	s.AddTool(scanServicesTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "prowler"}
		if provider := request.GetString("provider", ""); provider != "" {
			args = append(args, provider)
		}
		if services := request.GetString("services", ""); services != "" {
			args = append(args, "--services", services)
		}
		if region := request.GetString("region", ""); region != "" {
			args = append(args, "--region", region)
		}
		return executeShipCommand(args)
	})
}

func addTruffleHogTools(s *server.MCPServer) {
	// TruffleHog scan directory tool
	scanDirTool := mcp.NewTool("trufflehog_scan_directory",
		mcp.WithDescription("Scan a directory for secrets using TruffleHog"),
		mcp.WithString("directory",
			mcp.Description("Directory to scan (default: current directory)"),
		),
	)
	s.AddTool(scanDirTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "trufflehog"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		return executeShipCommand(args)
	})

	// TruffleHog scan git repository tool
	scanGitTool := mcp.NewTool("trufflehog_scan_git_repo",
		mcp.WithDescription("Scan a git repository for secrets using TruffleHog"),
		mcp.WithString("repo_url",
			mcp.Description("Git repository URL to scan"),
		),
	)
	s.AddTool(scanGitTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "trufflehog"}
		if repoURL := request.GetString("repo_url", ""); repoURL != "" {
			args = append(args, repoURL)
		}
		return executeShipCommand(args)
	})

	// TruffleHog scan GitHub repository tool
	scanGitHubTool := mcp.NewTool("trufflehog_scan_github",
		mcp.WithDescription("Scan a GitHub repository for secrets using TruffleHog"),
		mcp.WithString("repo",
			mcp.Description("GitHub repository (owner/repo format)"),
		),
		mcp.WithString("token",
			mcp.Description("GitHub token for repository access"),
		),
	)
	s.AddTool(scanGitHubTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "trufflehog"}
		if repo := request.GetString("repo", ""); repo != "" {
			args = append(args, repo)
		}
		if token := request.GetString("token", ""); token != "" {
			args = append(args, "--token", token)
		}
		return executeShipCommand(args)
	})

	// TruffleHog scan GitHub organization tool
	scanGitHubOrgTool := mcp.NewTool("trufflehog_scan_github_org",
		mcp.WithDescription("Scan a GitHub organization for secrets using TruffleHog"),
		mcp.WithString("org",
			mcp.Description("GitHub organization name"),
		),
		mcp.WithString("token",
			mcp.Description("GitHub token for organization access"),
		),
	)
	s.AddTool(scanGitHubOrgTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "trufflehog"}
		if org := request.GetString("org", ""); org != "" {
			args = append(args, org)
		}
		if token := request.GetString("token", ""); token != "" {
			args = append(args, "--token", token)
		}
		return executeShipCommand(args)
	})

	// TruffleHog scan Docker image tool
	scanDockerTool := mcp.NewTool("trufflehog_scan_docker_image",
		mcp.WithDescription("Scan a Docker image for secrets using TruffleHog"),
		mcp.WithString("image_name",
			mcp.Description("Docker image name to scan"),
		),
	)
	s.AddTool(scanDockerTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "trufflehog"}
		if imageName := request.GetString("image_name", ""); imageName != "" {
			args = append(args, imageName)
		}
		return executeShipCommand(args)
	})

	// TruffleHog scan S3 bucket tool
	scanS3Tool := mcp.NewTool("trufflehog_scan_s3",
		mcp.WithDescription("Scan an S3 bucket for secrets using TruffleHog"),
		mcp.WithString("bucket",
			mcp.Description("S3 bucket name to scan"),
		),
	)
	s.AddTool(scanS3Tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "trufflehog"}
		if bucket := request.GetString("bucket", ""); bucket != "" {
			args = append(args, bucket)
		}
		return executeShipCommand(args)
	})

	// TruffleHog scan with verification tool
	scanWithVerificationTool := mcp.NewTool("trufflehog_scan_with_verification",
		mcp.WithDescription("Scan with secret verification using TruffleHog"),
		mcp.WithString("target",
			mcp.Description("Target to scan (directory, repo, etc.)"),
		),
		mcp.WithString("target_type",
			mcp.Description("Type of target"),
			mcp.Enum("directory", "git", "github", "docker", "s3"),
		),
	)
	s.AddTool(scanWithVerificationTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "trufflehog"}
		if target := request.GetString("target", ""); target != "" {
			args = append(args, target)
		}
		if targetType := request.GetString("target_type", ""); targetType != "" {
			args = append(args, "--type", targetType)
		}
		args = append(args, "--verify")
		return executeShipCommand(args)
	})

	// Add the built-in AWS pricing tool
	addAWSPricingBuiltinTool(s)
}

func addCosignTools(s *server.MCPServer) {
	// Cosign verify image tool
	verifyImageTool := mcp.NewTool("cosign_verify_image",
		mcp.WithDescription("Verify container image signature using Cosign"),
		mcp.WithString("image_name",
			mcp.Description("Container image name to verify"),
		),
	)
	s.AddTool(verifyImageTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "cosign", "verify"}
		if imageName := request.GetString("image_name", ""); imageName != "" {
			args = append(args, imageName)
		}
		return executeShipCommand(args)
	})

	// Cosign verify image with key tool
	verifyWithKeyTool := mcp.NewTool("cosign_verify_image_with_key",
		mcp.WithDescription("Verify container image signature with public key using Cosign"),
		mcp.WithString("image_name",
			mcp.Description("Container image name to verify"),
		),
		mcp.WithString("public_key_path",
			mcp.Description("Path to public key file"),
		),
	)
	s.AddTool(verifyWithKeyTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "cosign", "verify"}
		if imageName := request.GetString("image_name", ""); imageName != "" {
			args = append(args, imageName)
		}
		if publicKey := request.GetString("public_key_path", ""); publicKey != "" {
			args = append(args, "--key", publicKey)
		}
		return executeShipCommand(args)
	})

	// Cosign sign image tool
	signImageTool := mcp.NewTool("cosign_sign_image",
		mcp.WithDescription("Sign container image using Cosign"),
		mcp.WithString("image_name",
			mcp.Description("Container image name to sign"),
		),
		mcp.WithString("private_key_path",
			mcp.Description("Path to private key file"),
		),
	)
	s.AddTool(signImageTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "cosign", "sign"}
		if imageName := request.GetString("image_name", ""); imageName != "" {
			args = append(args, imageName)
		}
		if privateKey := request.GetString("private_key_path", ""); privateKey != "" {
			args = append(args, "--key", privateKey)
		}
		return executeShipCommand(args)
	})

	// Cosign sign image keyless tool
	signKeylessTool := mcp.NewTool("cosign_sign_image_keyless",
		mcp.WithDescription("Sign container image keyless using Cosign"),
		mcp.WithString("image_name",
			mcp.Description("Container image name to sign"),
		),
	)
	s.AddTool(signKeylessTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "cosign", "sign"}
		if imageName := request.GetString("image_name", ""); imageName != "" {
			args = append(args, imageName)
		}
		args = append(args, "--keyless")
		return executeShipCommand(args)
	})

	// Cosign verify attestation tool
	verifyAttestationTool := mcp.NewTool("cosign_verify_attestation",
		mcp.WithDescription("Verify container image attestation using Cosign"),
		mcp.WithString("image_name",
			mcp.Description("Container image name to verify"),
		),
		mcp.WithString("attestation_type",
			mcp.Description("Type of attestation to verify"),
			mcp.Enum("slsa", "spdx", "cyclonedx", "custom"),
		),
	)
	s.AddTool(verifyAttestationTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "cosign", "verify-attestation"}
		if imageName := request.GetString("image_name", ""); imageName != "" {
			args = append(args, imageName)
		}
		if attestationType := request.GetString("attestation_type", ""); attestationType != "" {
			args = append(args, "--type", attestationType)
		}
		return executeShipCommand(args)
	})

	// Cosign generate key pair tool
	generateKeyPairTool := mcp.NewTool("cosign_generate_key_pair",
		mcp.WithDescription("Generate Cosign key pair"),
		mcp.WithString("output_dir",
			mcp.Description("Output directory for key files"),
		),
	)
	s.AddTool(generateKeyPairTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "cosign", "generate-key-pair"}
		if outputDir := request.GetString("output_dir", ""); outputDir != "" {
			args = append(args, "--output-dir", outputDir)
		}
		return executeShipCommand(args)
	})

	// Cosign attest SBOM tool
	attestSBOMTool := mcp.NewTool("cosign_attest_sbom",
		mcp.WithDescription("Attest SBOM to container image using Cosign"),
		mcp.WithString("image_name",
			mcp.Description("Container image name to attest"),
		),
		mcp.WithString("sbom_path",
			mcp.Description("Path to SBOM file"),
		),
		mcp.WithString("private_key_path",
			mcp.Description("Path to private key file"),
		),
	)
	s.AddTool(attestSBOMTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "cosign", "attest"}
		if imageName := request.GetString("image_name", ""); imageName != "" {
			args = append(args, imageName)
		}
		if sbomPath := request.GetString("sbom_path", ""); sbomPath != "" {
			args = append(args, "--predicate", sbomPath)
		}
		if privateKey := request.GetString("private_key_path", ""); privateKey != "" {
			args = append(args, "--key", privateKey)
		}
		return executeShipCommand(args)
	})
}

// AWS IAM Tools
func addAWSIAMTools(s *server.MCPServer) {
	addCloudsplainingTool(s)
	addParliamentTool(s)
	addPMapperTool(s)
	addPolicySentryTool(s)
}

// Cloud Tools Collection
func addCloudTools(s *server.MCPServer) {
	addCloudQueryTools(s)
	addCustodianTools(s)
	addTerraformerTool(s)
	addInfracostTool(s)
	addInframapTool(s)
	addInfrascanTool(s)
	addAWSIAMRotationTool(s)
	addTfstateReaderTool(s)
	addPackerTool(s)
	addPowerpipeTool(s)
	addIacPlanTool(s)
}

// Kubernetes Tools Collection
func addKubernetesTools(s *server.MCPServer) {
	addKubeBenchTool(s)
	addKubeHunterTool(s)
	addFalcoTools(s)
	addFleetTool(s)
	addKuttlTool(s)
	addLitmusTool(s)
	addCertManagerTool(s)
	addK8sNetworkPolicyTool(s)
	addKyvernoTools(s)
	addKyvernoMultitenantTool(s)
	addVeleroTool(s)
	addGoldilocksTool(s)
	addGatekeeperTool(s)
	addKubescapeTools(s)
}

func addCloudsplainingTool(s *server.MCPServer) {
	cloudsplainingTool := mcp.NewTool("cloudsplaining",
		mcp.WithDescription("AWS IAM security assessment using Cloudsplaining"),
		mcp.WithString("command",
			mcp.Description("Cloudsplaining command to execute"),
			mcp.Enum("scan-account", "scan-policy"),
		),
		mcp.WithString("profile",
			mcp.Description("AWS profile to use"),
		),
		mcp.WithString("policy-file",
			mcp.Description("IAM policy file to scan (for scan-policy command)"),
		),
		mcp.WithString("minimize",
			mcp.Description("Statement ID to minimize"),
		),
		mcp.WithString("output",
			mcp.Description("Output file to save results"),
		),
	)

	s.AddTool(cloudsplainingTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		command := request.GetString("command", "scan-account")
		args := []string{"security", "cloudsplaining", command}

		if policyFile := request.GetString("policy-file", ""); policyFile != "" && command == "scan-policy" {
			args = append(args, policyFile)
		}
		if profile := request.GetString("profile", ""); profile != "" {
			args = append(args, "--profile", profile)
		}
		if minimize := request.GetString("minimize", ""); minimize != "" {
			args = append(args, "--minimize", minimize)
		}
		if output := request.GetString("output", ""); output != "" {
			args = append(args, "--output", output)
		}

		return executeShipCommand(args)
	})
}

func addParliamentTool(s *server.MCPServer) {
	parliamentTool := mcp.NewTool("parliament",
		mcp.WithDescription("AWS IAM policy linting using Parliament"),
		mcp.WithString("policy-file",
			mcp.Description("IAM policy file to lint"),
		),
		mcp.WithBoolean("community",
			mcp.Description("Include community auditors"),
		),
		mcp.WithString("auditors",
			mcp.Description("Path to private auditors directory"),
		),
		mcp.WithString("severity",
			mcp.Description("Minimum severity level"),
		),
		mcp.WithString("output",
			mcp.Description("Output file to save results"),
		),
	)

	s.AddTool(parliamentTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "parliament"}

		if policyFile := request.GetString("policy-file", ""); policyFile != "" {
			args = append(args, policyFile)
		}
		if community := request.GetBool("community", false); community {
			args = append(args, "--community")
		}
		if auditors := request.GetString("auditors", ""); auditors != "" {
			args = append(args, "--auditors", auditors)
		}
		if severity := request.GetString("severity", ""); severity != "" {
			args = append(args, "--severity", severity)
		}
		if output := request.GetString("output", ""); output != "" {
			args = append(args, "--output", output)
		}

		return executeShipCommand(args)
	})
}

func addPMapperTool(s *server.MCPServer) {
	pmapperTool := mcp.NewTool("pmapper",
		mcp.WithDescription("AWS IAM privilege mapping using PMapper"),
		mcp.WithString("command",
			mcp.Description("PMapper command to execute"),
			mcp.Enum("create-graph", "query", "privesc", "admin", "list", "visualize"),
		),
		mcp.WithString("profile",
			mcp.Description("AWS profile to use"),
		),
		mcp.WithString("principal",
			mcp.Description("Principal name for queries"),
		),
		mcp.WithString("action",
			mcp.Description("Action for access queries"),
		),
		mcp.WithString("resource",
			mcp.Description("Resource ARN for access queries"),
		),
		mcp.WithString("format",
			mcp.Description("Output format for visualization"),
		),
		mcp.WithString("output",
			mcp.Description("Output file to save results"),
		),
	)

	s.AddTool(pmapperTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		command := request.GetString("command", "create-graph")
		args := []string{"security", "pmapper", command}

		if principal := request.GetString("principal", ""); principal != "" {
			args = append(args, principal)
		}
		if action := request.GetString("action", ""); action != "" {
			args = append(args, action)
		}
		if resource := request.GetString("resource", ""); resource != "" {
			args = append(args, resource)
		}
		if profile := request.GetString("profile", ""); profile != "" {
			args = append(args, "--profile", profile)
		}
		if format := request.GetString("format", ""); format != "" {
			args = append(args, "--format", format)
		}
		if output := request.GetString("output", ""); output != "" {
			args = append(args, "--output", output)
		}

		return executeShipCommand(args)
	})
}

func addPolicySentryTool(s *server.MCPServer) {
	policySentryTool := mcp.NewTool("policy-sentry",
		mcp.WithDescription("AWS IAM policy generation using Policy Sentry"),
		mcp.WithString("command",
			mcp.Description("Policy Sentry command to execute"),
			mcp.Enum("create-template", "write-policy", "query-actions", "query-conditions"),
		),
		mcp.WithString("template-type",
			mcp.Description("Template type for create-template"),
			mcp.Enum("crud", "actions"),
		),
		mcp.WithString("input",
			mcp.Description("Input YAML file for write-policy"),
		),
		mcp.WithString("service",
			mcp.Description("AWS service for query commands"),
		),
		mcp.WithString("output",
			mcp.Description("Output file to save results"),
		),
	)

	s.AddTool(policySentryTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		command := request.GetString("command", "create-template")
		args := []string{"security", "policy-sentry", command}

		if templateType := request.GetString("template-type", ""); templateType != "" {
			args = append(args, "--template-type", templateType)
		}
		if input := request.GetString("input", ""); input != "" {
			args = append(args, "--input", input)
		}
		if service := request.GetString("service", ""); service != "" {
			args = append(args, "--service", service)
		}
		if output := request.GetString("output", ""); output != "" {
			args = append(args, "--output", output)
		}

		return executeShipCommand(args)
	})
}

func executeShipCommand(args []string) (*mcp.CallToolResult, error) {
	// Get the current binary path
	executable, err := os.Executable()
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to get executable path: %v", err)), nil
	}

	// Execute the ship command
	cmd := exec.Command(executable, args...)
	output, err := cmd.CombinedOutput()

	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Command failed: %s\n\nOutput:\n%s", err.Error(), string(output))), nil
	}

	outputStr := string(output)

	// Check if output needs to be chunked
	if needsChunking(outputStr) {
		return createChunkedResponse(outputStr), nil
	}

	return mcp.NewToolResultText(outputStr), nil
}

func needsChunking(text string) bool {
	return utf8.RuneCountInString(text) > (maxMCPTokens * charsPerToken)
}

func createChunkedResponse(text string) *mcp.CallToolResult {
	maxChunkSize := maxMCPTokens * charsPerToken

	// Split text into chunks, preferring to break at newlines
	chunks := smartChunk(text, maxChunkSize)

	if len(chunks) <= 1 {
		return mcp.NewToolResultText(text)
	}

	// Create a summary response with information about chunking
	summary := fmt.Sprintf(`Output is large (%d characters, ~%d tokens) and has been summarized.

TOTAL CHUNKS: %d

SUMMARY OF FIRST CHUNK:
%s

--- [Content continues in additional chunks] ---

To see the full output, you can:
1. Run the command with smaller scope (specific directory/subset)
2. Use filtering options if available
3. Process chunks individually if needed

FIRST CHUNK PREVIEW (showing first %d characters):
%s`,
		utf8.RuneCountInString(text),
		utf8.RuneCountInString(text)/charsPerToken,
		len(chunks),
		getChunkSummary(chunks[0]),
		maxChunkSize/4, // Show 1/4 of max chunk size as preview
		truncateText(chunks[0], maxChunkSize/4),
	)

	return mcp.NewToolResultText(summary)
}

func smartChunk(text string, maxSize int) []string {
	if utf8.RuneCountInString(text) <= maxSize {
		return []string{text}
	}

	var chunks []string
	lines := strings.Split(text, "\n")

	currentChunk := ""
	currentSize := 0

	for _, line := range lines {
		lineSize := utf8.RuneCountInString(line) + 1 // +1 for newline

		// If adding this line would exceed the chunk size, start a new chunk
		if currentSize+lineSize > maxSize && currentChunk != "" {
			chunks = append(chunks, strings.TrimSuffix(currentChunk, "\n"))
			currentChunk = line + "\n"
			currentSize = lineSize
		} else {
			currentChunk += line + "\n"
			currentSize += lineSize
		}
	}

	// Add the last chunk if it has content
	if currentChunk != "" {
		chunks = append(chunks, strings.TrimSuffix(currentChunk, "\n"))
	}

	return chunks
}

func getChunkSummary(chunk string) string {
	lines := strings.Split(chunk, "\n")
	if len(lines) == 0 {
		return "Empty content"
	}

	// Try to identify the type of content
	firstLine := strings.TrimSpace(lines[0])

	if strings.Contains(chunk, "CRITICAL") || strings.Contains(chunk, "HIGH") {
		return "Security scan results with findings"
	} else if strings.Contains(chunk, "resource \"") {
		return "Terraform configuration analysis"
	} else if strings.Contains(chunk, "$") && strings.Contains(chunk, "cost") {
		return "Cost analysis results"
	} else if strings.Contains(chunk, "Error:") || strings.Contains(chunk, "Warning:") {
		return "Tool output with errors/warnings"
	} else {
		return fmt.Sprintf("Tool output starting with: %s", truncateText(firstLine, 100))
	}
}

func truncateText(text string, maxLen int) string {
	if utf8.RuneCountInString(text) <= maxLen {
		return text
	}

	runes := []rune(text)
	if len(runes) <= maxLen {
		return text
	}

	return string(runes[:maxLen]) + "..."
}

// isExternalMCPServer checks if the tool name matches a hardcoded external MCP server
func isExternalMCPServer(toolName string) bool {
	_, exists := hardcodedMCPServers[toolName]
	return exists
}

// runMCPProxy starts an MCP proxy server for external MCP servers
func runMCPProxy(cmd *cobra.Command, serverName string) error {
	useStdio, _ := cmd.Flags().GetBool("stdio")
	port, _ := cmd.Flags().GetInt("port")
	envVars, _ := cmd.Flags().GetStringToString("var")

	// Get hardcoded server configuration
	mcpConfig, exists := hardcodedMCPServers[serverName]
	if !exists {
		return fmt.Errorf("external MCP server '%s' not found in hardcoded configurations", serverName)
	}

	// Validate and merge environment variables
	if err := validateAndMergeVariables(&mcpConfig, envVars); err != nil {
		return fmt.Errorf("variable validation failed: %w", err)
	}

	ctx := context.Background()

	// Create and connect proxy
	proxy := ship.NewMCPProxy(mcpConfig)
	if err := proxy.Connect(ctx); err != nil {
		return fmt.Errorf("failed to connect to external MCP server: %w", err)
	}
	defer proxy.Close()

	// Discover tools from the external server
	tools, err := proxy.DiscoverTools(ctx)
	if err != nil {
		return fmt.Errorf("failed to discover tools from external server: %w", err)
	}

	fmt.Fprintf(os.Stderr, "Discovered %d tools from external MCP server\n", len(tools))

	// Create a Ship MCP server with the discovered tools
	shipServer := ship.NewServer(fmt.Sprintf("ship-proxy-%s", serverName), "1.0.0")
	for _, tool := range tools {
		shipServer.AddTool(tool)
	}
	mcpServer := shipServer.Build()
	defer mcpServer.Close()

	// Start the server
	if err := mcpServer.Start(ctx); err != nil {
		return fmt.Errorf("failed to start MCP server: %w", err)
	}

	// Get the mcp-go server instance
	serverInstance := mcpServer.GetMCPGoServer()
	if serverInstance == nil {
		return fmt.Errorf("failed to get MCP server instance")
	}

	// Start the proxy server
	if useStdio || port == 0 {
		fmt.Fprintf(os.Stderr, "Starting Ship proxy for %s on stdio...\n", serverName)
		fmt.Fprintf(os.Stderr, "Available tools: %v\n", mcpServer.GetRegistry().ListTools())
		return server.ServeStdio(serverInstance)
	} else {
		return fmt.Errorf("HTTP server not implemented in this version, use --stdio")
	}
}

// validateAndMergeVariables validates required variables and merges user-provided vars with config
func validateAndMergeVariables(config *ship.MCPServerConfig, userVars map[string]string) error {
	if config.Variables == nil {
		return nil
	}

	// Check for required variables
	for _, variable := range config.Variables {
		if variable.Required {
			// Check if provided by user
			if _, exists := userVars[variable.Name]; !exists {
				// Check if has default value
				if variable.Default == "" {
					return fmt.Errorf("required variable %s is missing (use --var %s=value)",
						variable.Name, variable.Name)
				}
			}
		}
	}

	// Merge variables into config.Env
	if config.Env == nil {
		config.Env = make(map[string]string)
	}

	// First, set defaults for variables that aren't provided
	for _, variable := range config.Variables {
		if _, exists := userVars[variable.Name]; !exists && variable.Default != "" {
			config.Env[variable.Name] = variable.Default
		}
	}

	// Then, override with user-provided values
	for key, value := range userVars {
		config.Env[key] = value
	}

	return nil
}

// setContainerEnvironmentVars sets environment variables for containerized tools
func setContainerEnvironmentVars(envVars map[string]string) {
	for key, value := range envVars {
		os.Setenv(key, value)
	}
}

// showVariableHelp displays information about available variables for a tool
func showVariableHelp(serverName string) {
	config, exists := hardcodedMCPServers[serverName]
	if !exists || len(config.Variables) == 0 {
		return
	}

	fmt.Fprintf(os.Stderr, "\nAvailable variables for %s:\n", serverName)
	for _, variable := range config.Variables {
		required := ""
		if variable.Required {
			required = " (required)"
		}

		secret := ""
		if variable.Secret {
			secret = " (secret)"
		}

		defaultInfo := ""
		if variable.Default != "" {
			defaultInfo = fmt.Sprintf(" [default: %s]", variable.Default)
		}

		fmt.Fprintf(os.Stderr, "  --var %s=value%s%s%s\n    %s\n",
			variable.Name, defaultInfo, required, secret, variable.Description)
	}
	fmt.Fprintf(os.Stderr, "\n")
}

// New high-priority security tools MCP functions
func addSLSAVerifierTool(s *server.MCPServer) {
	tool := mcp.NewTool("slsa-verifier",
		mcp.WithDescription("SLSA provenance verification for supply chain security"),
		mcp.WithString("command", mcp.Description("SLSA command"), mcp.Enum("verify-artifact", "verify-image", "generate-policy")),
		mcp.WithString("artifact", mcp.Description("Path to artifact file")),
		mcp.WithString("provenance", mcp.Description("Path to provenance file")),
		mcp.WithString("source-uri", mcp.Description("Source URI for verification")),
		mcp.WithString("builder-id", mcp.Description("Builder ID for verification")),
		mcp.WithBoolean("print-provenance", mcp.Description("Print provenance information")),
	)
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "slsa-verifier"}
		if command := request.GetString("command", ""); command != "" {
			args = append(args, command)
		}
		if artifact := request.GetString("artifact", ""); artifact != "" {
			args = append(args, "--artifact", artifact)
		}
		if provenance := request.GetString("provenance", ""); provenance != "" {
			args = append(args, "--provenance", provenance)
		}
		if sourceURI := request.GetString("source-uri", ""); sourceURI != "" {
			args = append(args, "--source-uri", sourceURI)
		}
		if builderID := request.GetString("builder-id", ""); builderID != "" {
			args = append(args, "--builder-id", builderID)
		}
		if printProvenance := request.GetBool("print-provenance", false); printProvenance {
			args = append(args, "--print-provenance")
		}
		return executeShipCommand(args)
	})
}

func addInTotoTool(s *server.MCPServer) {
	tool := mcp.NewTool("in-toto",
		mcp.WithDescription("Supply chain attestation using in-toto"),
		mcp.WithString("command", mcp.Description("in-toto command"), mcp.Enum("run", "verify", "record", "generate-layout")),
		mcp.WithString("step-name", mcp.Description("Step name for attestation")),
		mcp.WithString("key", mcp.Description("Path to signing key")),
		mcp.WithString("layout", mcp.Description("Path to layout file")),
	)
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "in-toto"}
		if command := request.GetString("command", ""); command != "" {
			args = append(args, command)
		}
		if stepName := request.GetString("step-name", ""); stepName != "" {
			args = append(args, "--step-name", stepName)
		}
		if key := request.GetString("key", ""); key != "" {
			args = append(args, "--key", key)
		}
		if layout := request.GetString("layout", ""); layout != "" {
			args = append(args, "--layout", layout)
		}
		return executeShipCommand(args)
	})
}

func addGatekeeperTool(s *server.MCPServer) {
	tool := mcp.NewTool("gatekeeper",
		mcp.WithDescription("OPA Gatekeeper policy validation"),
		mcp.WithString("command", mcp.Description("Gatekeeper command"), mcp.Enum("validate", "test", "generate-template", "sync", "analyze")),
		mcp.WithString("constraints", mcp.Description("Path to constraints directory")),
		mcp.WithString("templates", mcp.Description("Path to constraint templates directory")),
		mcp.WithString("resources", mcp.Description("Path to resources directory")),
		mcp.WithString("format", mcp.Description("Output format")),
		mcp.WithBoolean("verbose", mcp.Description("Verbose output")),
	)
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "gatekeeper"}
		if command := request.GetString("command", ""); command != "" {
			args = append(args, command)
		}
		if constraints := request.GetString("constraints", ""); constraints != "" {
			args = append(args, "--constraints", constraints)
		}
		if templates := request.GetString("templates", ""); templates != "" {
			args = append(args, "--templates", templates)
		}
		if resources := request.GetString("resources", ""); resources != "" {
			args = append(args, "--resources", resources)
		}
		if format := request.GetString("format", ""); format != "" {
			args = append(args, "--format", format)
		}
		if verbose := request.GetBool("verbose", false); verbose {
			args = append(args, "--verbose")
		}
		return executeShipCommand(args)
	})
}

func addKubescapeTools(s *server.MCPServer) {
	// Kubescape scan cluster tool
	scanClusterTool := mcp.NewTool("kubescape_scan_cluster",
		mcp.WithDescription("Scan Kubernetes cluster using Kubescape"),
		mcp.WithString("framework",
			mcp.Description("Security framework to use"),
			mcp.Enum("nsa", "mitre", "cis", "all"),
		),
		mcp.WithString("kubeconfig",
			mcp.Description("Path to kubeconfig file"),
		),
	)
	s.AddTool(scanClusterTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "kubescape", "cluster"}
		if framework := request.GetString("framework", ""); framework != "" {
			args = append(args, "--framework", framework)
		}
		if kubeconfig := request.GetString("kubeconfig", ""); kubeconfig != "" {
			args = append(args, "--kubeconfig", kubeconfig)
		}
		return executeShipCommand(args)
	})

	// Kubescape scan manifests tool
	scanManifestsTool := mcp.NewTool("kubescape_scan_manifests",
		mcp.WithDescription("Scan Kubernetes manifests using Kubescape"),
		mcp.WithString("manifests_dir",
			mcp.Description("Directory containing Kubernetes manifests"),
		),
		mcp.WithString("framework",
			mcp.Description("Security framework to use"),
			mcp.Enum("nsa", "mitre", "cis", "all"),
		),
	)
	s.AddTool(scanManifestsTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "kubescape", "manifests"}
		if manifestsDir := request.GetString("manifests_dir", ""); manifestsDir != "" {
			args = append(args, manifestsDir)
		}
		if framework := request.GetString("framework", ""); framework != "" {
			args = append(args, "--framework", framework)
		}
		return executeShipCommand(args)
	})

	// Kubescape scan Helm chart tool
	scanHelmTool := mcp.NewTool("kubescape_scan_helm",
		mcp.WithDescription("Scan Helm chart using Kubescape"),
		mcp.WithString("chart_path",
			mcp.Description("Path to Helm chart directory"),
		),
		mcp.WithString("framework",
			mcp.Description("Security framework to use"),
			mcp.Enum("nsa", "mitre", "cis", "all"),
		),
	)
	s.AddTool(scanHelmTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "kubescape", "helm"}
		if chartPath := request.GetString("chart_path", ""); chartPath != "" {
			args = append(args, chartPath)
		}
		if framework := request.GetString("framework", ""); framework != "" {
			args = append(args, "--framework", framework)
		}
		return executeShipCommand(args)
	})

	// Kubescape scan repository tool
	scanRepositoryTool := mcp.NewTool("kubescape_scan_repository",
		mcp.WithDescription("Scan repository for Kubernetes security issues using Kubescape"),
		mcp.WithString("repo_path",
			mcp.Description("Path to repository directory"),
		),
		mcp.WithString("framework",
			mcp.Description("Security framework to use"),
			mcp.Enum("nsa", "mitre", "cis", "all"),
		),
	)
	s.AddTool(scanRepositoryTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "kubescape", "repo"}
		if repoPath := request.GetString("repo_path", ""); repoPath != "" {
			args = append(args, repoPath)
		}
		if framework := request.GetString("framework", ""); framework != "" {
			args = append(args, "--framework", framework)
		}
		return executeShipCommand(args)
	})

	// Kubescape generate report tool
	generateReportTool := mcp.NewTool("kubescape_generate_report",
		mcp.WithDescription("Generate security report using Kubescape"),
		mcp.WithString("input_path",
			mcp.Description("Path to scan results or manifests"),
		),
		mcp.WithString("format",
			mcp.Description("Report format"),
			mcp.Enum("json", "junit", "pdf", "html"),
		),
	)
	s.AddTool(generateReportTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "kubescape", "report"}
		if inputPath := request.GetString("input_path", ""); inputPath != "" {
			args = append(args, inputPath)
		}
		if format := request.GetString("format", ""); format != "" {
			args = append(args, "--format", format)
		}
		return executeShipCommand(args)
	})
}

func addDockleTool(s *server.MCPServer) {
	tool := mcp.NewTool("dockle",
		mcp.WithDescription("Container image linting using Dockle"),
		mcp.WithString("image", mcp.Description("Container image to scan")),
		mcp.WithString("format", mcp.Description("Output format")),
		mcp.WithString("exit-level", mcp.Description("Exit level")),
	)
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "dockle"}
		if image := request.GetString("image", ""); image != "" {
			args = append(args, image)
		}
		if format := request.GetString("format", ""); format != "" {
			args = append(args, "--format", format)
		}
		if exitLevel := request.GetString("exit-level", ""); exitLevel != "" {
			args = append(args, "--exit-level", exitLevel)
		}
		return executeShipCommand(args)
	})
}

func addSOPSTool(s *server.MCPServer) {
	tool := mcp.NewTool("sops",
		mcp.WithDescription("Secrets management using Mozilla SOPS"),
		mcp.WithString("command", mcp.Description("SOPS command"), mcp.Enum("encrypt", "decrypt", "rotate", "edit", "generate-config", "validate")),
		mcp.WithString("file", mcp.Description("File to operate on")),
		mcp.WithString("kms", mcp.Description("KMS ARN for encryption")),
		mcp.WithString("pgp", mcp.Description("PGP fingerprint for encryption")),
		mcp.WithString("age", mcp.Description("Age public key for encryption")),
		mcp.WithBoolean("in-place", mcp.Description("Edit file in place")),
	)
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "sops"}
		if command := request.GetString("command", ""); command != "" {
			args = append(args, command)
		}
		if file := request.GetString("file", ""); file != "" {
			args = append(args, file)
		}
		if kms := request.GetString("kms", ""); kms != "" {
			args = append(args, "--kms", kms)
		}
		if pgp := request.GetString("pgp", ""); pgp != "" {
			args = append(args, "--pgp", pgp)
		}
		if age := request.GetString("age", ""); age != "" {
			args = append(args, "--age", age)
		}
		if inPlace := request.GetBool("in-place", false); inPlace {
			args = append(args, "--in-place")
		}
		return executeShipCommand(args)
	})
}

// Additional Security Tools MCP Functions
func addActionlintTools(s *server.MCPServer) {
	// Actionlint scan directory tool
	scanDirectoryTool := mcp.NewTool("actionlint_scan_directory",
		mcp.WithDescription("Scan a directory for GitHub Actions workflow issues using Actionlint"),
		mcp.WithString("directory",
			mcp.Description("Directory to scan (default: current directory)"),
		),
	)
	s.AddTool(scanDirectoryTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "actionlint"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		return executeShipCommand(args)
	})

	// Actionlint scan file tool
	scanFileTool := mcp.NewTool("actionlint_scan_file",
		mcp.WithDescription("Scan a specific workflow file using Actionlint"),
		mcp.WithString("file_path",
			mcp.Description("Path to the workflow file to scan"),
			mcp.Required(),
		),
	)
	s.AddTool(scanFileTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		filePath := request.GetString("file_path", "")
		args := []string{"security", "actionlint", "--file", filePath}
		return executeShipCommand(args)
	})

	// Actionlint get version tool
	getVersionTool := mcp.NewTool("actionlint_get_version",
		mcp.WithDescription("Get the version of Actionlint"),
	)
	s.AddTool(getVersionTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "actionlint", "--version"}
		return executeShipCommand(args)
	})
}

func addSemgrepTools(s *server.MCPServer) {
	// Semgrep scan directory tool
	scanDirectoryTool := mcp.NewTool("semgrep_scan_directory",
		mcp.WithDescription("Scan directory for security issues using Semgrep"),
		mcp.WithString("directory",
			mcp.Description("Directory to scan (default: current directory)"),
		),
	)
	s.AddTool(scanDirectoryTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "semgrep"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		return executeShipCommand(args)
	})

	// Semgrep scan with ruleset tool
	scanWithRulesetTool := mcp.NewTool("semgrep_scan_with_ruleset",
		mcp.WithDescription("Scan with specific ruleset using Semgrep"),
		mcp.WithString("directory",
			mcp.Description("Directory to scan (default: current directory)"),
		),
		mcp.WithString("ruleset",
			mcp.Description("Semgrep ruleset to use"),
			mcp.Enum("auto", "p/security-audit", "p/python", "p/javascript", "p/go", "p/java"),
		),
	)
	s.AddTool(scanWithRulesetTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "semgrep"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		if ruleset := request.GetString("ruleset", ""); ruleset != "" {
			args = append(args, "--config", ruleset)
		}
		return executeShipCommand(args)
	})

	// Semgrep scan file tool
	scanFileTool := mcp.NewTool("semgrep_scan_file",
		mcp.WithDescription("Scan specific file using Semgrep"),
		mcp.WithString("file_path",
			mcp.Description("Path to the file to scan"),
		),
	)
	s.AddTool(scanFileTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "semgrep"}
		if filePath := request.GetString("file_path", ""); filePath != "" {
			args = append(args, filePath)
		}
		return executeShipCommand(args)
	})

	// Semgrep get version tool
	getVersionTool := mcp.NewTool("semgrep_get_version",
		mcp.WithDescription("Get Semgrep version information"),
	)
	s.AddTool(getVersionTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "semgrep", "--version"}
		return executeShipCommand(args)
	})
}

func addHadolintTools(s *server.MCPServer) {
	// Hadolint scan dockerfile tool
	scanDockerfileTool := mcp.NewTool("hadolint_scan_dockerfile",
		mcp.WithDescription("Scan a specific Dockerfile for best practices using Hadolint"),
		mcp.WithString("dockerfile_path",
			mcp.Description("Path to the Dockerfile to scan"),
			mcp.Required(),
		),
	)
	s.AddTool(scanDockerfileTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		dockerfilePath := request.GetString("dockerfile_path", "")
		args := []string{"security", "hadolint", "--file", dockerfilePath}
		return executeShipCommand(args)
	})

	// Hadolint scan directory tool
	scanDirectoryTool := mcp.NewTool("hadolint_scan_directory",
		mcp.WithDescription("Scan all Dockerfiles in a directory using Hadolint"),
		mcp.WithString("directory",
			mcp.Description("Directory to scan (default: current directory)"),
		),
	)
	s.AddTool(scanDirectoryTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "hadolint"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		return executeShipCommand(args)
	})

	// Hadolint get version tool
	getVersionTool := mcp.NewTool("hadolint_get_version",
		mcp.WithDescription("Get the version of Hadolint"),
	)
	s.AddTool(getVersionTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "hadolint", "--version"}
		return executeShipCommand(args)
	})
}

func addCfnNagTool(s *server.MCPServer) {
	tool := mcp.NewTool("cfn-nag",
		mcp.WithDescription("CloudFormation security scanning"),
		mcp.WithString("directory", mcp.Description("Directory to scan (default: current directory)")),
		mcp.WithString("rules", mcp.Description("Path to custom rules directory")),
		mcp.WithString("output", mcp.Description("Output file to save results")),
	)
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "cfn-nag"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		if rules := request.GetString("rules", ""); rules != "" {
			args = append(args, "--rules", rules)
		}
		if output := request.GetString("output", ""); output != "" {
			args = append(args, "--output", output)
		}
		return executeShipCommand(args)
	})
}

func addConftestTools(s *server.MCPServer) {
	// Conftest test with policy tool
	testWithPolicyTool := mcp.NewTool("conftest_test_with_policy",
		mcp.WithDescription("Test files against OPA policies using Conftest"),
		mcp.WithString("directory",
			mcp.Description("Directory to scan (default: current directory)"),
		),
		mcp.WithString("policy_path",
			mcp.Description("Path to policy directory"),
			mcp.Required(),
		),
	)
	s.AddTool(testWithPolicyTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "conftest"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		policyPath := request.GetString("policy_path", "")
		args = append(args, "--policy", policyPath)
		return executeShipCommand(args)
	})

	// Conftest test file tool
	testFileTool := mcp.NewTool("conftest_test_file",
		mcp.WithDescription("Test a specific file against policies using Conftest"),
		mcp.WithString("file_path",
			mcp.Description("Path to the file to test"),
			mcp.Required(),
		),
		mcp.WithString("policy_path",
			mcp.Description("Path to policy directory"),
			mcp.Required(),
		),
	)
	s.AddTool(testFileTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		filePath := request.GetString("file_path", "")
		policyPath := request.GetString("policy_path", "")
		args := []string{"security", "conftest", "--file", filePath, "--policy", policyPath}
		return executeShipCommand(args)
	})

	// Conftest get version tool
	getVersionTool := mcp.NewTool("conftest_get_version",
		mcp.WithDescription("Get the version of Conftest"),
	)
	s.AddTool(getVersionTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "conftest", "--version"}
		return executeShipCommand(args)
	})
}

func addGitSecretsTools(s *server.MCPServer) {
	// Git-secrets scan repository tool
	scanRepositoryTool := mcp.NewTool("git_secrets_scan_repository",
		mcp.WithDescription("Scan a git repository for secrets using git-secrets"),
		mcp.WithString("directory",
			mcp.Description("Directory to scan (default: current directory)"),
		),
	)
	s.AddTool(scanRepositoryTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "git-secrets"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		return executeShipCommand(args)
	})

	// Git-secrets scan with AWS providers tool
	scanWithAwsTool := mcp.NewTool("git_secrets_scan_aws",
		mcp.WithDescription("Scan with AWS secret patterns using git-secrets"),
		mcp.WithString("directory",
			mcp.Description("Directory to scan (default: current directory)"),
		),
	)
	s.AddTool(scanWithAwsTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "git-secrets", "--aws"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		return executeShipCommand(args)
	})

	// Git-secrets get version tool
	getVersionTool := mcp.NewTool("git_secrets_get_version",
		mcp.WithDescription("Get the version of git-secrets"),
	)
	s.AddTool(getVersionTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "git-secrets", "--version"}
		return executeShipCommand(args)
	})
}

func addKubeBenchTool(s *server.MCPServer) {
	tool := mcp.NewTool("kube-bench",
		mcp.WithDescription("Kubernetes security benchmarks"),
		mcp.WithString("kubeconfig", mcp.Description("Path to kubeconfig file")),
		mcp.WithString("node-type", mcp.Description("Node type (master, node)")),
		mcp.WithString("output", mcp.Description("Output file to save results")),
	)
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "kube-bench"}
		if kubeconfig := request.GetString("kubeconfig", ""); kubeconfig != "" {
			args = append(args, "--kubeconfig", kubeconfig)
		}
		if nodeType := request.GetString("node-type", ""); nodeType != "" {
			args = append(args, "--node-type", nodeType)
		}
		if output := request.GetString("output", ""); output != "" {
			args = append(args, "--output", output)
		}
		return executeShipCommand(args)
	})
}

func addKubeHunterTool(s *server.MCPServer) {
	tool := mcp.NewTool("kube-hunter",
		mcp.WithDescription("Kubernetes penetration testing"),
		mcp.WithString("scan-type", mcp.Description("Scan type (remote, cidr, interface, pod)")),
		mcp.WithString("kubeconfig", mcp.Description("Path to kubeconfig file (for pod scan)")),
		mcp.WithString("output", mcp.Description("Output file to save results")),
	)
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "kube-hunter"}
		if scanType := request.GetString("scan-type", ""); scanType != "" {
			args = append(args, "--scan-type", scanType)
		}
		if kubeconfig := request.GetString("kubeconfig", ""); kubeconfig != "" {
			args = append(args, "--kubeconfig", kubeconfig)
		}
		if output := request.GetString("output", ""); output != "" {
			args = append(args, "--output", output)
		}
		return executeShipCommand(args)
	})
}

func addZapTools(s *server.MCPServer) {
	// ZAP baseline scan tool
	baselineScanTool := mcp.NewTool("zap_baseline_scan",
		mcp.WithDescription("Run a baseline security scan using OWASP ZAP"),
		mcp.WithString("target",
			mcp.Description("Target URL to scan"),
			mcp.Required(),
		),
	)
	s.AddTool(baselineScanTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		target := request.GetString("target", "")
		args := []string{"security", "zap", target, "--scan-type", "baseline"}
		return executeShipCommand(args)
	})

	// ZAP full scan tool
	fullScanTool := mcp.NewTool("zap_full_scan",
		mcp.WithDescription("Run a comprehensive security scan using OWASP ZAP"),
		mcp.WithString("target",
			mcp.Description("Target URL to scan"),
			mcp.Required(),
		),
		mcp.WithNumber("max_duration",
			mcp.Description("Maximum scan duration in minutes"),
		),
	)
	s.AddTool(fullScanTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		target := request.GetString("target", "")
		args := []string{"security", "zap", target, "--scan-type", "full"}
		if maxDuration := request.GetInt("max_duration", 0); maxDuration > 0 {
			args = append(args, "--max-duration", fmt.Sprintf("%d", maxDuration))
		}
		return executeShipCommand(args)
	})

	// ZAP API scan tool
	apiScanTool := mcp.NewTool("zap_api_scan",
		mcp.WithDescription("Scan an API using OWASP ZAP with OpenAPI/Swagger spec"),
		mcp.WithString("target",
			mcp.Description("Target API URL to scan"),
			mcp.Required(),
		),
		mcp.WithString("api_spec_path",
			mcp.Description("Path to OpenAPI/Swagger spec file"),
			mcp.Required(),
		),
	)
	s.AddTool(apiScanTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		target := request.GetString("target", "")
		apiSpecPath := request.GetString("api_spec_path", "")
		args := []string{"security", "zap", target, "--scan-type", "api", "--api-spec", apiSpecPath}
		return executeShipCommand(args)
	})

	// ZAP scan with context tool
	scanWithContextTool := mcp.NewTool("zap_scan_with_context",
		mcp.WithDescription("Scan with ZAP context file for authenticated scanning"),
		mcp.WithString("target",
			mcp.Description("Target URL to scan"),
			mcp.Required(),
		),
		mcp.WithString("context_path",
			mcp.Description("Path to ZAP context file"),
			mcp.Required(),
		),
	)
	s.AddTool(scanWithContextTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		target := request.GetString("target", "")
		contextPath := request.GetString("context_path", "")
		args := []string{"security", "zap", target, "--context", contextPath}
		return executeShipCommand(args)
	})

	// ZAP get version tool
	getVersionTool := mcp.NewTool("zap_get_version",
		mcp.WithDescription("Get the version of OWASP ZAP"),
	)
	s.AddTool(getVersionTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "zap", "--version"}
		return executeShipCommand(args)
	})
}

func addFalcoTools(s *server.MCPServer) {
	// Falco run with default rules tool
	runDefaultTool := mcp.NewTool("falco_run_default",
		mcp.WithDescription("Run Falco with default security rules"),
		mcp.WithString("kubeconfig",
			mcp.Description("Path to kubeconfig file"),
		),
	)
	s.AddTool(runDefaultTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "falco"}
		if kubeconfig := request.GetString("kubeconfig", ""); kubeconfig != "" {
			args = append(args, "--kubeconfig", kubeconfig)
		}
		return executeShipCommand(args)
	})

	// Falco run with custom rules tool
	runCustomTool := mcp.NewTool("falco_run_custom",
		mcp.WithDescription("Run Falco with custom security rules"),
		mcp.WithString("rules_path",
			mcp.Description("Path to custom rules directory"),
			mcp.Required(),
		),
		mcp.WithString("kubeconfig",
			mcp.Description("Path to kubeconfig file"),
		),
	)
	s.AddTool(runCustomTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		rulesPath := request.GetString("rules_path", "")
		args := []string{"security", "falco", "--rules", rulesPath}
		if kubeconfig := request.GetString("kubeconfig", ""); kubeconfig != "" {
			args = append(args, "--kubeconfig", kubeconfig)
		}
		return executeShipCommand(args)
	})

	// Falco validate rules tool
	validateRulesTool := mcp.NewTool("falco_validate_rules",
		mcp.WithDescription("Validate Falco security rules"),
		mcp.WithString("rules_path",
			mcp.Description("Path to rules directory to validate"),
			mcp.Required(),
		),
	)
	s.AddTool(validateRulesTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		rulesPath := request.GetString("rules_path", "")
		args := []string{"security", "falco", "--rules", rulesPath, "--validate"}
		return executeShipCommand(args)
	})

	// Falco get version tool
	getVersionTool := mcp.NewTool("falco_get_version",
		mcp.WithDescription("Get the version of Falco"),
	)
	s.AddTool(getVersionTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "falco", "--version"}
		return executeShipCommand(args)
	})
}

func addNiktoTools(s *server.MCPServer) {
	// Nikto scan host tool
	scanHostTool := mcp.NewTool("nikto_scan_host",
		mcp.WithDescription("Scan a web host for vulnerabilities using Nikto"),
		mcp.WithString("host",
			mcp.Description("Target host to scan"),
			mcp.Required(),
		),
	)
	s.AddTool(scanHostTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		host := request.GetString("host", "")
		args := []string{"security", "nikto", "--host", host}
		return executeShipCommand(args)
	})

	// Nikto SSL scan tool
	scanSSLTool := mcp.NewTool("nikto_scan_ssl",
		mcp.WithDescription("Scan a host with SSL/TLS analysis using Nikto"),
		mcp.WithString("host",
			mcp.Description("Target host to scan"),
			mcp.Required(),
		),
		mcp.WithNumber("port",
			mcp.Description("Port to scan"),
			mcp.Required(),
		),
	)
	s.AddTool(scanSSLTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		host := request.GetString("host", "")
		port := request.GetInt("port", 0)
		args := []string{"security", "nikto", "--host", host, "--port", fmt.Sprintf("%d", port), "--ssl"}
		return executeShipCommand(args)
	})

	// Nikto scan with tuning tool
	scanTunedTool := mcp.NewTool("nikto_scan_tuned",
		mcp.WithDescription("Scan with specific tuning options using Nikto"),
		mcp.WithString("host",
			mcp.Description("Target host to scan"),
			mcp.Required(),
		),
		mcp.WithString("tuning",
			mcp.Description("Tuning options for scan (e.g., '1', '2', '3', etc.)"),
			mcp.Required(),
		),
	)
	s.AddTool(scanTunedTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		host := request.GetString("host", "")
		tuning := request.GetString("tuning", "")
		args := []string{"security", "nikto", "--host", host, "--tuning", tuning}
		return executeShipCommand(args)
	})

	// Nikto get version tool
	getVersionTool := mcp.NewTool("nikto_get_version",
		mcp.WithDescription("Get the version of Nikto scanner"),
	)
	s.AddTool(getVersionTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "nikto", "--version"}
		return executeShipCommand(args)
	})
}

func addOpenSCAPTool(s *server.MCPServer) {
	tool := mcp.NewTool("openscap", mcp.WithDescription("Security compliance scanning"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "openscap"})
	})
}

func addOSSFScorecardTool(s *server.MCPServer) {
	tool := mcp.NewTool("ossf-scorecard", mcp.WithDescription("Open Source Security Foundation scorecard"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "ossf-scorecard"})
	})
}

func addScoutSuiteTool(s *server.MCPServer) {
	tool := mcp.NewTool("scout-suite", mcp.WithDescription("Multi-cloud security auditing"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "scout-suite"})
	})
}


func addPowerpipeTool(s *server.MCPServer) {
	tool := mcp.NewTool("powerpipe", mcp.WithDescription("Infrastructure benchmarking"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "powerpipe"})
	})
}

func addVeleroTool(s *server.MCPServer) {
	tool := mcp.NewTool("velero", mcp.WithDescription("Kubernetes backup and disaster recovery"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "velero"})
	})
}

func addGoldilocksTool(s *server.MCPServer) {
	tool := mcp.NewTool("goldilocks", mcp.WithDescription("Kubernetes resource recommendations"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "goldilocks"})
	})
}

func addAllstarTool(s *server.MCPServer) {
	tool := mcp.NewTool("allstar", mcp.WithDescription("GitHub security policy enforcement"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "allstar"})
	})
}

func addRekorTool(s *server.MCPServer) {
	tool := mcp.NewTool("rekor", mcp.WithDescription("Software supply chain transparency"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "rekor"})
	})
}

func addOSVScannerTool(s *server.MCPServer) {
	tool := mcp.NewTool("osv-scanner", mcp.WithDescription("Open Source Vulnerability scanning"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "osv-scanner"})
	})
}

func addLicenseDetectorTool(s *server.MCPServer) {
	tool := mcp.NewTool("license-detector", mcp.WithDescription("Software license detection"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "license-detector"})
	})
}

func addRegistryTool(s *server.MCPServer) {
	tool := mcp.NewTool("registry", mcp.WithDescription("Container registry operations"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "registry"})
	})
}

func addCosignGoldenTool(s *server.MCPServer) {
	tool := mcp.NewTool("cosign-golden", mcp.WithDescription("Enhanced Cosign for golden images"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "cosign-golden"})
	})
}

func addHistoryScrubTool(s *server.MCPServer) {
	tool := mcp.NewTool("history-scrub", mcp.WithDescription("Git history cleaning and secret removal"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "history-scrub"})
	})
}

func addTrivyGoldenTool(s *server.MCPServer) {
	tool := mcp.NewTool("trivy-golden", mcp.WithDescription("Enhanced Trivy for golden images"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "trivy-golden"})
	})
}

func addIacPlanTool(s *server.MCPServer) {
	tool := mcp.NewTool("iac-plan", mcp.WithDescription("Infrastructure as Code planning"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "iac-plan"})
	})
}

// Cloud & Infrastructure Tools MCP Functions
func addCloudQueryTools(s *server.MCPServer) {
	// CloudQuery sync with config tool
	syncWithConfigTool := mcp.NewTool("cloudquery_sync_with_config",
		mcp.WithDescription("Sync cloud resources using CloudQuery config"),
		mcp.WithString("config_path",
			mcp.Description("Path to CloudQuery config file"),
			mcp.Required(),
		),
	)
	s.AddTool(syncWithConfigTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		configPath := request.GetString("config_path", "")
		args := []string{"security", "cloudquery", "--sync", configPath}
		return executeShipCommand(args)
	})

	// CloudQuery validate config tool
	validateConfigTool := mcp.NewTool("cloudquery_validate_config",
		mcp.WithDescription("Validate CloudQuery configuration file"),
		mcp.WithString("config_path",
			mcp.Description("Path to CloudQuery config file"),
			mcp.Required(),
		),
	)
	s.AddTool(validateConfigTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		configPath := request.GetString("config_path", "")
		args := []string{"security", "cloudquery", "--validate", configPath}
		return executeShipCommand(args)
	})

	// CloudQuery list providers tool
	listProvidersTool := mcp.NewTool("cloudquery_list_providers",
		mcp.WithDescription("List available CloudQuery providers"),
	)
	s.AddTool(listProvidersTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "cloudquery", "--list-providers"}
		return executeShipCommand(args)
	})

	// CloudQuery get version tool
	getVersionTool := mcp.NewTool("cloudquery_get_version",
		mcp.WithDescription("Get the version of CloudQuery"),
	)
	s.AddTool(getVersionTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "cloudquery", "--version"}
		return executeShipCommand(args)
	})
}

func addCustodianTools(s *server.MCPServer) {
	// Custodian run policy tool
	runPolicyTool := mcp.NewTool("custodian_run_policy",
		mcp.WithDescription("Run Cloud Custodian policy"),
		mcp.WithString("policy_path",
			mcp.Description("Path to policy file"),
			mcp.Required(),
		),
		mcp.WithString("output_dir",
			mcp.Description("Output directory for results"),
		),
	)
	s.AddTool(runPolicyTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		policyPath := request.GetString("policy_path", "")
		args := []string{"security", "custodian", "--run", policyPath}
		if outputDir := request.GetString("output_dir", ""); outputDir != "" {
			args = append(args, "--output", outputDir)
		}
		return executeShipCommand(args)
	})

	// Custodian validate policy tool
	validatePolicyTool := mcp.NewTool("custodian_validate_policy",
		mcp.WithDescription("Validate Cloud Custodian policy syntax"),
		mcp.WithString("policy_path",
			mcp.Description("Path to policy file"),
			mcp.Required(),
		),
	)
	s.AddTool(validatePolicyTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		policyPath := request.GetString("policy_path", "")
		args := []string{"security", "custodian", "--validate", policyPath}
		return executeShipCommand(args)
	})

	// Custodian dry run tool
	dryRunTool := mcp.NewTool("custodian_dry_run",
		mcp.WithDescription("Dry run Cloud Custodian policy to preview actions"),
		mcp.WithString("policy_path",
			mcp.Description("Path to policy file"),
			mcp.Required(),
		),
	)
	s.AddTool(dryRunTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		policyPath := request.GetString("policy_path", "")
		args := []string{"security", "custodian", "--dryrun", policyPath}
		return executeShipCommand(args)
	})
}

func addTerraformerTool(s *server.MCPServer) {
	tool := mcp.NewTool("terraformer", mcp.WithDescription("Infrastructure import and management"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "terraformer"})
	})
}

func addInfracostTool(s *server.MCPServer) {
	tool := mcp.NewTool("infracost", mcp.WithDescription("Infrastructure cost estimation"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "infracost"})
	})
}

func addInframapTool(s *server.MCPServer) {
	tool := mcp.NewTool("inframap", mcp.WithDescription("Infrastructure visualization"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "inframap"})
	})
}

func addInfrascanTool(s *server.MCPServer) {
	tool := mcp.NewTool("infrascan", mcp.WithDescription("Infrastructure security scanning"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "infrascan"})
	})
}

func addAWSIAMRotationTool(s *server.MCPServer) {
	tool := mcp.NewTool("aws-iam-rotation", mcp.WithDescription("AWS IAM credential rotation"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "aws-iam-rotation"})
	})
}

func addTfstateReaderTool(s *server.MCPServer) {
	tool := mcp.NewTool("tfstate-reader", mcp.WithDescription("Terraform state analysis"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "tfstate-reader"})
	})
}

func addPackerTool(s *server.MCPServer) {
	tool := mcp.NewTool("packer", mcp.WithDescription("Machine image building"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "packer"})
	})
}

func addFleetTool(s *server.MCPServer) {
	tool := mcp.NewTool("fleet", mcp.WithDescription("GitOps for Kubernetes"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "fleet"})
	})
}

func addKuttlTool(s *server.MCPServer) {
	tool := mcp.NewTool("kuttl", mcp.WithDescription("Kubernetes testing framework"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "kuttl"})
	})
}

func addLitmusTool(s *server.MCPServer) {
	tool := mcp.NewTool("litmus", mcp.WithDescription("Chaos engineering for Kubernetes"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "litmus"})
	})
}

func addCertManagerTool(s *server.MCPServer) {
	tool := mcp.NewTool("cert-manager", mcp.WithDescription("Certificate management"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "cert-manager"})
	})
}

func addStepCATool(s *server.MCPServer) {
	tool := mcp.NewTool("step-ca", mcp.WithDescription("Certificate authority operations"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "step-ca"})
	})
}

func addCheckSSLCertTool(s *server.MCPServer) {
	tool := mcp.NewTool("check-ssl-cert", mcp.WithDescription("SSL certificate validation"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "check-ssl-cert"})
	})
}

func addK8sNetworkPolicyTool(s *server.MCPServer) {
	tool := mcp.NewTool("k8s-network-policy", mcp.WithDescription("Kubernetes network policy management"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "k8s-network-policy"})
	})
}

func addKyvernoTools(s *server.MCPServer) {
	// Kyverno apply policies tool
	applyPoliciesTool := mcp.NewTool("kyverno_apply_policies",
		mcp.WithDescription("Apply Kyverno policies to Kubernetes cluster"),
		mcp.WithString("policies_path",
			mcp.Description("Path to policies directory"),
			mcp.Required(),
		),
		mcp.WithString("kubeconfig",
			mcp.Description("Path to kubeconfig file"),
			mcp.Required(),
		),
	)
	s.AddTool(applyPoliciesTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		policiesPath := request.GetString("policies_path", "")
		kubeconfig := request.GetString("kubeconfig", "")
		args := []string{"security", "kyverno", "--apply", policiesPath, "--kubeconfig", kubeconfig}
		return executeShipCommand(args)
	})

	// Kyverno validate policies tool
	validatePoliciesTool := mcp.NewTool("kyverno_validate_policies",
		mcp.WithDescription("Validate Kyverno policy syntax and structure"),
		mcp.WithString("policies_path",
			mcp.Description("Path to policies directory"),
			mcp.Required(),
		),
	)
	s.AddTool(validatePoliciesTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		policiesPath := request.GetString("policies_path", "")
		args := []string{"security", "kyverno", "--validate", policiesPath}
		return executeShipCommand(args)
	})

	// Kyverno test policies tool
	testPoliciesTool := mcp.NewTool("kyverno_test_policies",
		mcp.WithDescription("Test Kyverno policies against resources"),
		mcp.WithString("policies_path",
			mcp.Description("Path to policies directory"),
			mcp.Required(),
		),
		mcp.WithString("resources_path",
			mcp.Description("Path to test resources"),
			mcp.Required(),
		),
	)
	s.AddTool(testPoliciesTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		policiesPath := request.GetString("policies_path", "")
		resourcesPath := request.GetString("resources_path", "")
		args := []string{"security", "kyverno", "--test", policiesPath, "--resources", resourcesPath}
		return executeShipCommand(args)
	})

	// Kyverno get version tool
	getVersionTool := mcp.NewTool("kyverno_get_version",
		mcp.WithDescription("Get the version of Kyverno"),
	)
	s.AddTool(getVersionTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "kyverno", "--version"}
		return executeShipCommand(args)
	})
}

func addKyvernoMultitenantTool(s *server.MCPServer) {
	tool := mcp.NewTool("kyverno-multitenant", mcp.WithDescription("Multi-tenant Kyverno policies"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "kyverno-multitenant"})
	})
}

func addGitHubAdminTool(s *server.MCPServer) {
	tool := mcp.NewTool("github-admin", mcp.WithDescription("GitHub administration tools"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "github-admin"})
	})
}

func addGitHubPackagesTool(s *server.MCPServer) {
	tool := mcp.NewTool("github-packages", mcp.WithDescription("GitHub Packages security"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"security", "github-packages"})
	})
}

// Terraform Tools
func addTerraformDocsTool(s *server.MCPServer) {
	tool := mcp.NewTool("terraform-docs", mcp.WithDescription("Terraform documentation generation"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"tf", "docs"})
	})
}

func addTflintTools(s *server.MCPServer) {
	// TFLint lint directory tool
	lintDirTool := mcp.NewTool("tflint_lint_directory",
		mcp.WithDescription("Lint Terraform files in directory using TFLint"),
		mcp.WithString("directory",
			mcp.Description("Directory to lint (default: current directory)"),
		),
	)
	s.AddTool(lintDirTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"tf", "lint"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		return executeShipCommand(args)
	})

	// TFLint lint file tool
	lintFileTool := mcp.NewTool("tflint_lint_file",
		mcp.WithDescription("Lint specific Terraform file using TFLint"),
		mcp.WithString("file_path",
			mcp.Description("Path to Terraform file to lint"),
		),
	)
	s.AddTool(lintFileTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"tf", "lint"}
		if filePath := request.GetString("file_path", ""); filePath != "" {
			args = append(args, "--file", filePath)
		}
		return executeShipCommand(args)
	})

	// TFLint lint with config tool
	lintWithConfigTool := mcp.NewTool("tflint_lint_with_config",
		mcp.WithDescription("Lint Terraform with custom config using TFLint"),
		mcp.WithString("directory",
			mcp.Description("Directory to lint (default: current directory)"),
		),
		mcp.WithString("config_file",
			mcp.Description("Path to TFLint configuration file"),
		),
	)
	s.AddTool(lintWithConfigTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"tf", "lint"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		if configFile := request.GetString("config_file", ""); configFile != "" {
			args = append(args, "--config", configFile)
		}
		return executeShipCommand(args)
	})

	// TFLint lint with rules tool
	lintWithRulesTool := mcp.NewTool("tflint_lint_with_rules",
		mcp.WithDescription("Lint Terraform with specific rules using TFLint"),
		mcp.WithString("directory",
			mcp.Description("Directory to lint (default: current directory)"),
		),
		mcp.WithString("enable_rules",
			mcp.Description("Comma-separated list of rules to enable"),
		),
		mcp.WithString("disable_rules",
			mcp.Description("Comma-separated list of rules to disable"),
		),
	)
	s.AddTool(lintWithRulesTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"tf", "lint"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		if enableRules := request.GetString("enable_rules", ""); enableRules != "" {
			args = append(args, "--enable-rule", enableRules)
		}
		if disableRules := request.GetString("disable_rules", ""); disableRules != "" {
			args = append(args, "--disable-rule", disableRules)
		}
		return executeShipCommand(args)
	})

	// TFLint init plugins tool
	initPluginsTool := mcp.NewTool("tflint_init_plugins",
		mcp.WithDescription("Initialize TFLint plugins"),
		mcp.WithString("directory",
			mcp.Description("Directory to initialize plugins in (default: current directory)"),
		),
	)
	s.AddTool(initPluginsTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"tf", "lint", "--init"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		return executeShipCommand(args)
	})

	// TFLint get version tool
	getVersionTool := mcp.NewTool("tflint_get_version",
		mcp.WithDescription("Get TFLint version information"),
	)
	s.AddTool(getVersionTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"tf", "lint", "--version"}
		return executeShipCommand(args)
	})
}

func addTerrascanTools(s *server.MCPServer) {
	// Terrascan scan directory tool
	scanDirTool := mcp.NewTool("terrascan_scan_directory",
		mcp.WithDescription("Scan directory for Infrastructure as Code security issues using Terrascan"),
		mcp.WithString("directory",
			mcp.Description("Directory to scan (default: current directory)"),
		),
	)
	s.AddTool(scanDirTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "terrascan"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		return executeShipCommand(args)
	})

	// Terrascan scan Terraform tool
	scanTerraformTool := mcp.NewTool("terrascan_scan_terraform",
		mcp.WithDescription("Scan Terraform files for security issues using Terrascan"),
		mcp.WithString("directory",
			mcp.Description("Directory containing Terraform files (default: current directory)"),
		),
	)
	s.AddTool(scanTerraformTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "terrascan", "--iac-type", "terraform"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		return executeShipCommand(args)
	})

	// Terrascan scan Kubernetes tool
	scanKubernetesTool := mcp.NewTool("terrascan_scan_kubernetes",
		mcp.WithDescription("Scan Kubernetes manifests for security issues using Terrascan"),
		mcp.WithString("directory",
			mcp.Description("Directory containing Kubernetes manifests (default: current directory)"),
		),
	)
	s.AddTool(scanKubernetesTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "terrascan", "--iac-type", "k8s"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		return executeShipCommand(args)
	})

	// Terrascan scan CloudFormation tool
	scanCloudFormationTool := mcp.NewTool("terrascan_scan_cloudformation",
		mcp.WithDescription("Scan CloudFormation templates for security issues using Terrascan"),
		mcp.WithString("directory",
			mcp.Description("Directory containing CloudFormation templates (default: current directory)"),
		),
	)
	s.AddTool(scanCloudFormationTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "terrascan", "--iac-type", "cfn"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		return executeShipCommand(args)
	})

	// Terrascan scan Dockerfiles tool
	scanDockerfilesTool := mcp.NewTool("terrascan_scan_dockerfiles",
		mcp.WithDescription("Scan Dockerfiles for security issues using Terrascan"),
		mcp.WithString("directory",
			mcp.Description("Directory containing Dockerfiles (default: current directory)"),
		),
	)
	s.AddTool(scanDockerfilesTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "terrascan", "--iac-type", "docker"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		return executeShipCommand(args)
	})

	// Terrascan scan with severity tool
	scanWithSeverityTool := mcp.NewTool("terrascan_scan_with_severity",
		mcp.WithDescription("Scan with severity threshold using Terrascan"),
		mcp.WithString("directory",
			mcp.Description("Directory to scan (default: current directory)"),
		),
		mcp.WithString("severity",
			mcp.Description("Minimum severity level"),
			mcp.Enum("low", "medium", "high"),
		),
		mcp.WithString("iac_type",
			mcp.Description("Infrastructure as Code type"),
			mcp.Enum("terraform", "k8s", "cfn", "docker"),
		),
	)
	s.AddTool(scanWithSeverityTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "terrascan"}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, dir)
		}
		if severity := request.GetString("severity", ""); severity != "" {
			args = append(args, "--severity", severity)
		}
		if iacType := request.GetString("iac_type", ""); iacType != "" {
			args = append(args, "--iac-type", iacType)
		}
		return executeShipCommand(args)
	})
}

func addOpenInfraQuoteTool(s *server.MCPServer) {
	tool := mcp.NewTool("openinfraquote", mcp.WithDescription("Infrastructure cost estimation"))
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return executeShipCommand([]string{"tf", "cost"})
	})
}

// Supply Chain Security Tools MCP Functions
func addDependencyTrackTool(s *server.MCPServer) {
	tool := mcp.NewTool("dependency-track",
		mcp.WithDescription("OWASP Dependency-Track SBOM analysis and vulnerability tracking"),
		mcp.WithString("command", mcp.Description("Command to run"), mcp.Enum("analyze", "report", "validate", "track")),
		mcp.WithString("directory", mcp.Description("Directory to scan (default: current directory)")),
		mcp.WithString("sbom", mcp.Description("Path to SBOM file")),
		mcp.WithString("format", mcp.Description("Report format (json, xml, html)")),
		mcp.WithString("output", mcp.Description("Output file to save results")),
	)
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "dependency-track"}
		if command := request.GetString("command", ""); command != "" {
			args = append(args, command)
		}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, "--directory", dir)
		}
		if sbom := request.GetString("sbom", ""); sbom != "" {
			args = append(args, "--sbom", sbom)
		}
		if format := request.GetString("format", ""); format != "" {
			args = append(args, "--format", format)
		}
		if output := request.GetString("output", ""); output != "" {
			args = append(args, "--output", output)
		}
		return executeShipCommand(args)
	})
}

func addAWSPricingBuiltinTool(s *server.MCPServer) {
	awsPricingTool := mcp.NewTool("aws-pricing-builtin",
		mcp.WithDescription("Built-in AWS pricing information using AWS CLI"),
		mcp.WithString("command",
			mcp.Description("AWS pricing command to execute"),
			mcp.Enum("ec2", "rds", "services", "calculate"),
		),
		mcp.WithString("instance-type",
			mcp.Description("EC2 instance type (e.g., t3.micro, t3.small)"),
		),
		mcp.WithString("instance-class",
			mcp.Description("RDS instance class (e.g., db.t3.micro, db.t3.small)"),
		),
		mcp.WithString("engine",
			mcp.Description("Database engine (e.g., MySQL, PostgreSQL)"),
		),
		mcp.WithString("resource-type",
			mcp.Description("Resource type for calculation (ec2, rds, s3)"),
		),
		mcp.WithString("size",
			mcp.Description("Size specification for the resource"),
		),
		mcp.WithString("region",
			mcp.Description("AWS region (default: us-east-1)"),
		),
		mcp.WithString("output",
			mcp.Description("Output file to save results"),
		),
	)

	s.AddTool(awsPricingTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		command := request.GetString("command", "calculate")
		args := []string{"tf", "aws-pricing", command}

		switch command {
		case "ec2":
			if instanceType := request.GetString("instance-type", ""); instanceType != "" {
				args = append(args, instanceType)
			}
			if region := request.GetString("region", ""); region != "" {
				args = append(args, region)
			}
		case "rds":
			if instanceClass := request.GetString("instance-class", ""); instanceClass != "" {
				args = append(args, instanceClass)
			}
			if engine := request.GetString("engine", ""); engine != "" {
				args = append(args, engine)
			}
			if region := request.GetString("region", ""); region != "" {
				args = append(args, region)
			}
		case "calculate":
			if resourceType := request.GetString("resource-type", ""); resourceType != "" {
				args = append(args, resourceType)
			}
			if size := request.GetString("size", ""); size != "" {
				args = append(args, size)
			}
			if region := request.GetString("region", ""); region != "" {
				args = append(args, region)
			}
		}

		if output := request.GetString("output", ""); output != "" {
			args = append(args, "--output", output)
		}

		return executeShipCommand(args)
	})
}

func addGuacTool(s *server.MCPServer) {
	tool := mcp.NewTool("guac",
		mcp.WithDescription("GUAC supply chain security analysis - Graph for Understanding Artifact Composition"),
		mcp.WithString("command", mcp.Description("Command to run"), mcp.Enum("collect", "query", "impact", "graph")),
		mcp.WithString("directory", mcp.Description("Directory to analyze (default: current directory)")),
		mcp.WithString("sbom", mcp.Description("Path to SBOM file")),
		mcp.WithString("artifact", mcp.Description("Path to artifact file")),
		mcp.WithString("package", mcp.Description("Package name to query")),
		mcp.WithString("vuln-id", mcp.Description("Vulnerability ID for impact analysis")),
		mcp.WithString("attestation", mcp.Description("Path to attestation file")),
		mcp.WithString("output", mcp.Description("Output file to save results")),
	)
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "guac"}
		if command := request.GetString("command", ""); command != "" {
			args = append(args, command)
		}
		if dir := request.GetString("directory", ""); dir != "" {
			args = append(args, "--directory", dir)
		}
		if sbom := request.GetString("sbom", ""); sbom != "" {
			args = append(args, "--sbom", sbom)
		}
		if artifact := request.GetString("artifact", ""); artifact != "" {
			args = append(args, "--artifact", artifact)
		}
		if pkg := request.GetString("package", ""); pkg != "" {
			args = append(args, "--package", pkg)
		}
		if vulnID := request.GetString("vuln-id", ""); vulnID != "" {
			args = append(args, "--vuln-id", vulnID)
		}
		if attestation := request.GetString("attestation", ""); attestation != "" {
			args = append(args, "--attestation", attestation)
		}
		if output := request.GetString("output", ""); output != "" {
			args = append(args, "--output", output)
		}
		return executeShipCommand(args)
	})
}

func addSigstorePolicyControllerTool(s *server.MCPServer) {
	tool := mcp.NewTool("sigstore-policy-controller",
		mcp.WithDescription("Sigstore Policy Controller for Kubernetes admission control and image verification"),
		mcp.WithString("command", mcp.Description("Command to run"), mcp.Enum("validate", "test", "verify", "generate", "validate-manifest", "check-compliance", "audit")),
		mcp.WithString("policy", mcp.Description("Path to policy file")),
		mcp.WithString("image", mcp.Description("Container image name")),
		mcp.WithString("public-key", mcp.Description("Path to public key file")),
		mcp.WithString("manifest", mcp.Description("Path to manifest file")),
		mcp.WithString("manifests", mcp.Description("Path to manifests directory")),
		mcp.WithString("namespace", mcp.Description("Kubernetes namespace")),
		mcp.WithString("key-ref", mcp.Description("Key reference for policy generation")),
		mcp.WithString("output", mcp.Description("Output file to save results")),
	)
	s.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		args := []string{"security", "sigstore-policy-controller"}
		if command := request.GetString("command", ""); command != "" {
			args = append(args, command)
		}
		if policy := request.GetString("policy", ""); policy != "" {
			args = append(args, "--policy", policy)
		}
		if image := request.GetString("image", ""); image != "" {
			args = append(args, "--image", image)
		}
		if publicKey := request.GetString("public-key", ""); publicKey != "" {
			args = append(args, "--public-key", publicKey)
		}
		if manifest := request.GetString("manifest", ""); manifest != "" {
			args = append(args, "--manifest", manifest)
		}
		if manifests := request.GetString("manifests", ""); manifests != "" {
			args = append(args, "--manifests", manifests)
		}
		if namespace := request.GetString("namespace", ""); namespace != "" {
			args = append(args, "--namespace", namespace)
		}
		if keyRef := request.GetString("key-ref", ""); keyRef != "" {
			args = append(args, "--key-ref", keyRef)
		}
		if output := request.GetString("output", ""); output != "" {
			args = append(args, "--output", output)
		}
		return executeShipCommand(args)
	})
}
